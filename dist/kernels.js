/**
 * Kernels related methods
 * This file it is a part of the Pandora Pyrrha Javascript library
 * 
 * @file kernels.js
 * @author Kostiantyn Smyrnov <kostysh@gmail.com>
 * @date 2018
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventKernelAdded = exports.addToMarket = exports.deploy = exports.fetchAll = exports.fetchKernel = exports.fetchComplexity = exports.fetchCurrentPrice = exports.fetchDataDim = exports.fetchIpfsAddress = exports.fetchAddressById = void 0;

var _errors = _interopRequireWildcard(require("./helpers/errors"));

var web3Helpers = _interopRequireWildcard(require("./helpers/web3"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Get Kernel address by kernel id
 * 
 * @param {number} id
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {string}
 */
const fetchAddressById = async (id, config) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.PandoraMarket || !config.contracts.PandoraMarket.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'PandoraMarket');
  }

  if (!config.addresses || !config.addresses.market) {
    throw (0, _errors.default)(_errors.ADDRESS_REQUIRED, 'Market');
  }

  const mar = new config.web3.eth.Contract(config.contracts.PandoraMarket.abi, config.addresses.market);
  const kernelContract = await mar.methods.kernels(id).call();
  return kernelContract;
};
/**
 * Get IPFS address from Kernel contract by the kernel address
 * 
 * @param {string} address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {string}
 */


exports.fetchAddressById = fetchAddressById;

const fetchIpfsAddress = async (address = '', config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.Kernel || !config.contracts.Kernel.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'Kernel');
  }

  const ker = new config.web3.eth.Contract(config.contracts.Kernel.abi, address);
  const ipfsAddress = await ker.methods.ipfsAddress().call();
  return String(ipfsAddress);
};
/**
 * Get data dim from Kernel contract by the kernel address
 * 
 * @param {string} address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {number}
 */


exports.fetchIpfsAddress = fetchIpfsAddress;

const fetchDataDim = async (address = '', config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.Kernel || !config.contracts.Kernel.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'Kernel');
  }

  const ker = new config.web3.eth.Contract(config.contracts.Kernel.abi, address);
  const dataDim = await ker.methods.dataDim().call();
  return Number.parseInt(dataDim, 10);
};
/**
 * Get current price from Kernel contract by the kernel address
 * 
 * @param {string} address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {number}
 */


exports.fetchDataDim = fetchDataDim;

const fetchCurrentPrice = async (address = '', config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.Kernel || !config.contracts.Kernel.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'Kernel');
  }

  const ker = new config.web3.eth.Contract(config.contracts.Kernel.abi, address);
  const currentPrice = await ker.methods.currentPrice().call();
  return Number.parseInt(currentPrice, 10);
};
/**
 * Get complexity from Kernel contract by the kernel address
 * 
 * @param {string} address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {number}
 */


exports.fetchCurrentPrice = fetchCurrentPrice;

const fetchComplexity = async (address = '', config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.Kernel || !config.contracts.Kernel.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'Kernel');
  }

  const ker = new config.web3.eth.Contract(config.contracts.Kernel.abi, address);
  const complexity = await ker.methods.complexity().call();
  return Number.parseInt(complexity, 10);
};
/**
 * Get Kernel by the kernel address
 * 
 * @param {string} address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} Promise object represents the {Object[]}
 */


exports.fetchComplexity = fetchComplexity;

const fetchKernel = async (address = '', config = {}) => {
  try {
    const ipfsAddress = await fetchIpfsAddress(address, config);
    const dataDim = await fetchDataDim(address, config);
    const currentPrice = await fetchCurrentPrice(address, config);
    const complexity = await fetchComplexity(address, config);
    return {
      address,
      ipfsAddress,
      dataDim,
      currentPrice,
      complexity
    };
  } catch (err) {
    return Promise.reject(err);
  }
};
/**
 * Get all kernels
 * 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} Promise object represents the {Object[]}
 */


exports.fetchKernel = fetchKernel;

const fetchAll = async (config = {}) => {
  let id = 0;
  let records = [];
  let error = [];

  try {
    // @todo Add method getKernelsCount to the PandoraMarket contract for avoid iterating with "try catch"
    while (true) {
      const kernelAddress = await fetchAddressById(id++, config); // can be 0x0

      if (+kernelAddress === 0) {
        break;
      }

      try {
        const kernelObj = await fetchKernel(kernelAddress, config);
        records.push(_objectSpread({
          id: id
        }, kernelObj));
      } catch (err) {
        error.push({
          address: kernelAddress,
          message: err.message
        });
      }
    }
  } catch (err) {
    error.push({
      error: err.message
    });
  }

  return {
    records,
    error
  };
};
/**
 * Deploy Kernel contract to the network
 * 
 * @param {string} kernelIpfsHash 
 * @param {Object} options { publisher, dimension, complexity, price } 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} Promise object resolved to contract address
 */


exports.fetchAll = fetchAll;

const deploy = async (kernelIpfsHash, {
  publisher,
  dimension,
  complexity,
  price
}, config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.Kernel || !config.contracts.Kernel.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'Kernel');
  }

  try {
    const args = [config.web3.utils.toHex(kernelIpfsHash), dimension, complexity, price]; // Estimate required amount of gas

    const gas = await web3Helpers.estimateGas(config.contracts.Kernel.bytecode, args, config); // Create and deploy kernel contract

    const kernelContractAddress = await web3Helpers.deployContract(config.contracts.Kernel, {
      args,
      from: publisher,
      gas: Number.parseInt(gas * 1.5, 10)
    }, config);
    return kernelContractAddress;
  } catch (err) {
    return Promise.reject(err);
  }
};
/**
 * Add kernel to market
 * 
 * @param {String} kernelContractAddress 
 * @param {String} publisherAddress 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} Promise object resolved to {string} contractAddress
 */


exports.deploy = deploy;

const addToMarket = (kernelContractAddress, publisherAddress, config = {}) => new Promise((resolve, reject) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.PandoraMarket || !config.contracts.PandoraMarket.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'PandoraMarket');
  }

  if (!config.addresses || !config.addresses.market) {
    throw (0, _errors.default)(_errors.ADDRESS_REQUIRED, 'Market');
  }

  if (!config.web3.currentProvider.isMetaMask) {
    throw (0, _errors.default)(_errors.WEB3_METAMASK_REQUIRED);
  }

  const market = new config.web3.eth.Contract(config.contracts.PandoraMarket.abi, config.addresses.market);
  market.methods.addKernel(kernelContractAddress).send({
    from: publisherAddress
  }).on('error', reject).on('receipt', receipt => resolve(receipt.contractAddress));
});
/**
 * Handle event KernelAdded
 * 
 * @param {Function} storeCallback 
 * @param {Function} errorCallback
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 */


exports.addToMarket = addToMarket;

const eventKernelAdded = (storeCallback = () => {}, errorCallback = () => {}, config = {}) => {
  if (!config.web3) {
    throw (0, _errors.default)(_errors.WEB3_REQUIRED);
  }

  if (!config.contracts || !config.contracts.PandoraMarket || !config.contracts.PandoraMarket.abi) {
    throw (0, _errors.default)(_errors.CONTRACT_REQUIRED, 'PandoraMarket');
  }

  if (!config.addresses || !config.addresses.market) {
    throw (0, _errors.default)(_errors.ADDRESS_REQUIRED, 'Market');
  }

  const mar = new config.web3.eth.Contract(config.contracts.PandoraMarket.abi, config.addresses.market);
  mar.events.KernelAdded({
    fromBlock: 0
  }).on('data', async res => {
    try {
      const kernel = await fetchKernel(res.args.kernel, config);
      storeCallback({
        address: res.args.kernel,
        kernel,
        status: 'created',
        event: 'PandoraMarket.KernelAdded'
      });
    } catch (err) {
      errorCallback(err);
    }
  }).on('error', errorCallback);
};

exports.eventKernelAdded = eventKernelAdded;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9rZXJuZWxzLmpzIl0sIm5hbWVzIjpbImZldGNoQWRkcmVzc0J5SWQiLCJpZCIsImNvbmZpZyIsIndlYjMiLCJXRUIzX1JFUVVJUkVEIiwiY29udHJhY3RzIiwiUGFuZG9yYU1hcmtldCIsImFiaSIsIkNPTlRSQUNUX1JFUVVJUkVEIiwiYWRkcmVzc2VzIiwibWFya2V0IiwiQUREUkVTU19SRVFVSVJFRCIsIm1hciIsImV0aCIsIkNvbnRyYWN0Iiwia2VybmVsQ29udHJhY3QiLCJtZXRob2RzIiwia2VybmVscyIsImNhbGwiLCJmZXRjaElwZnNBZGRyZXNzIiwiYWRkcmVzcyIsIktlcm5lbCIsImtlciIsImlwZnNBZGRyZXNzIiwiU3RyaW5nIiwiZmV0Y2hEYXRhRGltIiwiZGF0YURpbSIsIk51bWJlciIsInBhcnNlSW50IiwiZmV0Y2hDdXJyZW50UHJpY2UiLCJjdXJyZW50UHJpY2UiLCJmZXRjaENvbXBsZXhpdHkiLCJjb21wbGV4aXR5IiwiZmV0Y2hLZXJuZWwiLCJlcnIiLCJQcm9taXNlIiwicmVqZWN0IiwiZmV0Y2hBbGwiLCJyZWNvcmRzIiwiZXJyb3IiLCJrZXJuZWxBZGRyZXNzIiwia2VybmVsT2JqIiwicHVzaCIsIm1lc3NhZ2UiLCJkZXBsb3kiLCJrZXJuZWxJcGZzSGFzaCIsInB1Ymxpc2hlciIsImRpbWVuc2lvbiIsInByaWNlIiwiYXJncyIsInV0aWxzIiwidG9IZXgiLCJnYXMiLCJ3ZWIzSGVscGVycyIsImVzdGltYXRlR2FzIiwiYnl0ZWNvZGUiLCJrZXJuZWxDb250cmFjdEFkZHJlc3MiLCJkZXBsb3lDb250cmFjdCIsImZyb20iLCJhZGRUb01hcmtldCIsInB1Ymxpc2hlckFkZHJlc3MiLCJyZXNvbHZlIiwiY3VycmVudFByb3ZpZGVyIiwiaXNNZXRhTWFzayIsIldFQjNfTUVUQU1BU0tfUkVRVUlSRUQiLCJhZGRLZXJuZWwiLCJzZW5kIiwib24iLCJyZWNlaXB0IiwiY29udHJhY3RBZGRyZXNzIiwiZXZlbnRLZXJuZWxBZGRlZCIsInN0b3JlQ2FsbGJhY2siLCJlcnJvckNhbGxiYWNrIiwiZXZlbnRzIiwiS2VybmVsQWRkZWQiLCJmcm9tQmxvY2siLCJyZXMiLCJrZXJuZWwiLCJzdGF0dXMiLCJldmVudCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBU0E7Ozs7Ozs7QUFFQTs7QUFNQTs7Ozs7Ozs7QUFFQTs7Ozs7OztBQU9PLE1BQU1BLG1CQUFtQixPQUFPQyxFQUFQLEVBQVdDLE1BQVgsS0FBc0I7QUFFbEQsTUFBSSxDQUFDQSxPQUFPQyxJQUFaLEVBQWtCO0FBQ2QsVUFBTSxxQkFBU0MscUJBQVQsQ0FBTjtBQUNIOztBQUVELE1BQUksQ0FBQ0YsT0FBT0csU0FBUixJQUFxQixDQUFDSCxPQUFPRyxTQUFQLENBQWlCQyxhQUF2QyxJQUF3RCxDQUFDSixPQUFPRyxTQUFQLENBQWlCQyxhQUFqQixDQUErQkMsR0FBNUYsRUFBaUc7QUFDN0YsVUFBTSxxQkFBU0MseUJBQVQsRUFBNEIsZUFBNUIsQ0FBTjtBQUNIOztBQUVELE1BQUksQ0FBQ04sT0FBT08sU0FBUixJQUFxQixDQUFDUCxPQUFPTyxTQUFQLENBQWlCQyxNQUEzQyxFQUFtRDtBQUMvQyxVQUFNLHFCQUFTQyx3QkFBVCxFQUEyQixRQUEzQixDQUFOO0FBQ0g7O0FBRUQsUUFBTUMsTUFBTSxJQUFJVixPQUFPQyxJQUFQLENBQVlVLEdBQVosQ0FBZ0JDLFFBQXBCLENBQTZCWixPQUFPRyxTQUFQLENBQWlCQyxhQUFqQixDQUErQkMsR0FBNUQsRUFBaUVMLE9BQU9PLFNBQVAsQ0FBaUJDLE1BQWxGLENBQVo7QUFDQSxRQUFNSyxpQkFBaUIsTUFBTUgsSUFBSUksT0FBSixDQUN4QkMsT0FEd0IsQ0FDaEJoQixFQURnQixFQUV4QmlCLElBRndCLEVBQTdCO0FBR0EsU0FBT0gsY0FBUDtBQUNILENBbkJNO0FBcUJQOzs7Ozs7Ozs7OztBQU9PLE1BQU1JLG1CQUFtQixPQUFPQyxVQUFVLEVBQWpCLEVBQXFCbEIsU0FBUyxFQUE5QixLQUFxQztBQUVqRSxNQUFJLENBQUNBLE9BQU9DLElBQVosRUFBa0I7QUFDZCxVQUFNLHFCQUFTQyxxQkFBVCxDQUFOO0FBQ0g7O0FBRUQsTUFBSSxDQUFDRixPQUFPRyxTQUFSLElBQXFCLENBQUNILE9BQU9HLFNBQVAsQ0FBaUJnQixNQUF2QyxJQUFpRCxDQUFDbkIsT0FBT0csU0FBUCxDQUFpQmdCLE1BQWpCLENBQXdCZCxHQUE5RSxFQUFtRjtBQUMvRSxVQUFNLHFCQUFTQyx5QkFBVCxFQUE0QixRQUE1QixDQUFOO0FBQ0g7O0FBRUQsUUFBTWMsTUFBTSxJQUFJcEIsT0FBT0MsSUFBUCxDQUFZVSxHQUFaLENBQWdCQyxRQUFwQixDQUE2QlosT0FBT0csU0FBUCxDQUFpQmdCLE1BQWpCLENBQXdCZCxHQUFyRCxFQUEwRGEsT0FBMUQsQ0FBWjtBQUNBLFFBQU1HLGNBQWMsTUFBTUQsSUFBSU4sT0FBSixDQUNyQk8sV0FEcUIsR0FFckJMLElBRnFCLEVBQTFCO0FBR0EsU0FBT00sT0FBT0QsV0FBUCxDQUFQO0FBQ0gsQ0FmTTtBQWlCUDs7Ozs7Ozs7Ozs7QUFPTyxNQUFNRSxlQUFlLE9BQU9MLFVBQVUsRUFBakIsRUFBcUJsQixTQUFTLEVBQTlCLEtBQXFDO0FBRTdELE1BQUksQ0FBQ0EsT0FBT0MsSUFBWixFQUFrQjtBQUNkLFVBQU0scUJBQVNDLHFCQUFULENBQU47QUFDSDs7QUFFRCxNQUFJLENBQUNGLE9BQU9HLFNBQVIsSUFBcUIsQ0FBQ0gsT0FBT0csU0FBUCxDQUFpQmdCLE1BQXZDLElBQWlELENBQUNuQixPQUFPRyxTQUFQLENBQWlCZ0IsTUFBakIsQ0FBd0JkLEdBQTlFLEVBQW1GO0FBQy9FLFVBQU0scUJBQVNDLHlCQUFULEVBQTRCLFFBQTVCLENBQU47QUFDSDs7QUFFRCxRQUFNYyxNQUFNLElBQUlwQixPQUFPQyxJQUFQLENBQVlVLEdBQVosQ0FBZ0JDLFFBQXBCLENBQTZCWixPQUFPRyxTQUFQLENBQWlCZ0IsTUFBakIsQ0FBd0JkLEdBQXJELEVBQTBEYSxPQUExRCxDQUFaO0FBQ0EsUUFBTU0sVUFBVSxNQUFNSixJQUFJTixPQUFKLENBQ2pCVSxPQURpQixHQUVqQlIsSUFGaUIsRUFBdEI7QUFHQSxTQUFPUyxPQUFPQyxRQUFQLENBQWdCRixPQUFoQixFQUF5QixFQUF6QixDQUFQO0FBQ0gsQ0FmTTtBQWlCUDs7Ozs7Ozs7Ozs7QUFPTyxNQUFNRyxvQkFBb0IsT0FBT1QsVUFBVSxFQUFqQixFQUFxQmxCLFNBQVMsRUFBOUIsS0FBcUM7QUFFbEUsTUFBSSxDQUFDQSxPQUFPQyxJQUFaLEVBQWtCO0FBQ2QsVUFBTSxxQkFBU0MscUJBQVQsQ0FBTjtBQUNIOztBQUVELE1BQUksQ0FBQ0YsT0FBT0csU0FBUixJQUFxQixDQUFDSCxPQUFPRyxTQUFQLENBQWlCZ0IsTUFBdkMsSUFBaUQsQ0FBQ25CLE9BQU9HLFNBQVAsQ0FBaUJnQixNQUFqQixDQUF3QmQsR0FBOUUsRUFBbUY7QUFDL0UsVUFBTSxxQkFBU0MseUJBQVQsRUFBNEIsUUFBNUIsQ0FBTjtBQUNIOztBQUVELFFBQU1jLE1BQU0sSUFBSXBCLE9BQU9DLElBQVAsQ0FBWVUsR0FBWixDQUFnQkMsUUFBcEIsQ0FBNkJaLE9BQU9HLFNBQVAsQ0FBaUJnQixNQUFqQixDQUF3QmQsR0FBckQsRUFBMERhLE9BQTFELENBQVo7QUFDQSxRQUFNVSxlQUFlLE1BQU1SLElBQUlOLE9BQUosQ0FDdEJjLFlBRHNCLEdBRXRCWixJQUZzQixFQUEzQjtBQUdBLFNBQU9TLE9BQU9DLFFBQVAsQ0FBZ0JFLFlBQWhCLEVBQThCLEVBQTlCLENBQVA7QUFDSCxDQWZNO0FBaUJQOzs7Ozs7Ozs7OztBQU9PLE1BQU1DLGtCQUFrQixPQUFPWCxVQUFVLEVBQWpCLEVBQXFCbEIsU0FBUyxFQUE5QixLQUFxQztBQUVoRSxNQUFJLENBQUNBLE9BQU9DLElBQVosRUFBa0I7QUFDZCxVQUFNLHFCQUFTQyxxQkFBVCxDQUFOO0FBQ0g7O0FBRUQsTUFBSSxDQUFDRixPQUFPRyxTQUFSLElBQXFCLENBQUNILE9BQU9HLFNBQVAsQ0FBaUJnQixNQUF2QyxJQUFpRCxDQUFDbkIsT0FBT0csU0FBUCxDQUFpQmdCLE1BQWpCLENBQXdCZCxHQUE5RSxFQUFtRjtBQUMvRSxVQUFNLHFCQUFTQyx5QkFBVCxFQUE0QixRQUE1QixDQUFOO0FBQ0g7O0FBRUQsUUFBTWMsTUFBTSxJQUFJcEIsT0FBT0MsSUFBUCxDQUFZVSxHQUFaLENBQWdCQyxRQUFwQixDQUE2QlosT0FBT0csU0FBUCxDQUFpQmdCLE1BQWpCLENBQXdCZCxHQUFyRCxFQUEwRGEsT0FBMUQsQ0FBWjtBQUNBLFFBQU1ZLGFBQWEsTUFBTVYsSUFBSU4sT0FBSixDQUNwQmdCLFVBRG9CLEdBRXBCZCxJQUZvQixFQUF6QjtBQUdBLFNBQU9TLE9BQU9DLFFBQVAsQ0FBZ0JJLFVBQWhCLEVBQTRCLEVBQTVCLENBQVA7QUFDSCxDQWZNO0FBaUJQOzs7Ozs7Ozs7OztBQU9PLE1BQU1DLGNBQWMsT0FBT2IsVUFBVSxFQUFqQixFQUFxQmxCLFNBQVMsRUFBOUIsS0FBcUM7QUFFNUQsTUFBSTtBQUVBLFVBQU1xQixjQUFjLE1BQU1KLGlCQUFpQkMsT0FBakIsRUFBMEJsQixNQUExQixDQUExQjtBQUNBLFVBQU13QixVQUFVLE1BQU1ELGFBQWFMLE9BQWIsRUFBc0JsQixNQUF0QixDQUF0QjtBQUNBLFVBQU00QixlQUFlLE1BQU1ELGtCQUFrQlQsT0FBbEIsRUFBMkJsQixNQUEzQixDQUEzQjtBQUNBLFVBQU04QixhQUFhLE1BQU1ELGdCQUFnQlgsT0FBaEIsRUFBeUJsQixNQUF6QixDQUF6QjtBQUVBLFdBQU87QUFDSGtCLGFBREc7QUFFSEcsaUJBRkc7QUFHSEcsYUFIRztBQUlISSxrQkFKRztBQUtIRTtBQUxHLEtBQVA7QUFPSCxHQWRELENBY0UsT0FBTUUsR0FBTixFQUFXO0FBQ1QsV0FBT0MsUUFBUUMsTUFBUixDQUFlRixHQUFmLENBQVA7QUFDSDtBQUNKLENBbkJNO0FBcUJQOzs7Ozs7Ozs7O0FBTU8sTUFBTUcsV0FBVyxPQUFPbkMsU0FBUyxFQUFoQixLQUF1QjtBQUUzQyxNQUFJRCxLQUFLLENBQVQ7QUFDQSxNQUFJcUMsVUFBVSxFQUFkO0FBQ0EsTUFBSUMsUUFBUSxFQUFaOztBQUVBLE1BQUk7QUFFQTtBQUNBLFdBQU8sSUFBUCxFQUFhO0FBRVQsWUFBTUMsZ0JBQWdCLE1BQU14QyxpQkFBaUJDLElBQWpCLEVBQXVCQyxNQUF2QixDQUE1QixDQUZTLENBRWtEOztBQUUzRCxVQUFJLENBQUNzQyxhQUFELEtBQW1CLENBQXZCLEVBQTBCO0FBQ3RCO0FBQ0g7O0FBRUQsVUFBSTtBQUVBLGNBQU1DLFlBQVksTUFBTVIsWUFBWU8sYUFBWixFQUEyQnRDLE1BQTNCLENBQXhCO0FBRUFvQyxnQkFBUUksSUFBUjtBQUNJekMsY0FBSUE7QUFEUixXQUVPd0MsU0FGUDtBQUlILE9BUkQsQ0FRRSxPQUFNUCxHQUFOLEVBQVc7QUFFVEssY0FBTUcsSUFBTixDQUFXO0FBQ1B0QixtQkFBU29CLGFBREY7QUFFUEcsbUJBQVNULElBQUlTO0FBRk4sU0FBWDtBQUlIO0FBQ0o7QUFDSixHQTNCRCxDQTJCRSxPQUFNVCxHQUFOLEVBQVc7QUFDVEssVUFBTUcsSUFBTixDQUFXO0FBQ1BILGFBQU9MLElBQUlTO0FBREosS0FBWDtBQUdIOztBQUVELFNBQU87QUFDSEwsV0FERztBQUVIQztBQUZHLEdBQVA7QUFJSCxDQTNDTTtBQTZDUDs7Ozs7Ozs7Ozs7O0FBUU8sTUFBTUssU0FBUyxPQUFPQyxjQUFQLEVBQXVCO0FBQUVDLFdBQUY7QUFBYUMsV0FBYjtBQUF3QmYsWUFBeEI7QUFBb0NnQjtBQUFwQyxDQUF2QixFQUFvRTlDLFNBQVMsRUFBN0UsS0FBb0Y7QUFFdEcsTUFBSSxDQUFDQSxPQUFPQyxJQUFaLEVBQWtCO0FBQ2QsVUFBTSxxQkFBU0MscUJBQVQsQ0FBTjtBQUNIOztBQUVELE1BQUksQ0FBQ0YsT0FBT0csU0FBUixJQUFxQixDQUFDSCxPQUFPRyxTQUFQLENBQWlCZ0IsTUFBdkMsSUFBaUQsQ0FBQ25CLE9BQU9HLFNBQVAsQ0FBaUJnQixNQUFqQixDQUF3QmQsR0FBOUUsRUFBbUY7QUFDL0UsVUFBTSxxQkFBU0MseUJBQVQsRUFBNEIsUUFBNUIsQ0FBTjtBQUNIOztBQUVELE1BQUk7QUFDQSxVQUFNeUMsT0FBTyxDQUFDL0MsT0FBT0MsSUFBUCxDQUFZK0MsS0FBWixDQUFrQkMsS0FBbEIsQ0FBd0JOLGNBQXhCLENBQUQsRUFBMENFLFNBQTFDLEVBQXFEZixVQUFyRCxFQUFpRWdCLEtBQWpFLENBQWIsQ0FEQSxDQUdBOztBQUNBLFVBQU1JLE1BQU0sTUFBTUMsWUFBWUMsV0FBWixDQUF3QnBELE9BQU9HLFNBQVAsQ0FBaUJnQixNQUFqQixDQUF3QmtDLFFBQWhELEVBQTBETixJQUExRCxFQUFnRS9DLE1BQWhFLENBQWxCLENBSkEsQ0FNQTs7QUFDQSxVQUFNc0Qsd0JBQXdCLE1BQU1ILFlBQVlJLGNBQVosQ0FBMkJ2RCxPQUFPRyxTQUFQLENBQWlCZ0IsTUFBNUMsRUFBb0Q7QUFDcEY0QixVQURvRjtBQUVwRlMsWUFBTVosU0FGOEU7QUFHcEZNLFdBQUt6QixPQUFPQyxRQUFQLENBQWdCd0IsTUFBTSxHQUF0QixFQUEyQixFQUEzQjtBQUgrRSxLQUFwRCxFQUlqQ2xELE1BSmlDLENBQXBDO0FBTUEsV0FBT3NELHFCQUFQO0FBQ0gsR0FkRCxDQWNFLE9BQU10QixHQUFOLEVBQVc7QUFDVCxXQUFPQyxRQUFRQyxNQUFSLENBQWVGLEdBQWYsQ0FBUDtBQUNIO0FBQ0osQ0EzQk07QUE2QlA7Ozs7Ozs7Ozs7OztBQVFPLE1BQU15QixjQUFjLENBQUNILHFCQUFELEVBQXdCSSxnQkFBeEIsRUFBMEMxRCxTQUFTLEVBQW5ELEtBQTBELElBQUlpQyxPQUFKLENBQVksQ0FBQzBCLE9BQUQsRUFBVXpCLE1BQVYsS0FBcUI7QUFFbEgsTUFBSSxDQUFDbEMsT0FBT0MsSUFBWixFQUFrQjtBQUNkLFVBQU0scUJBQVNDLHFCQUFULENBQU47QUFDSDs7QUFFRCxNQUFJLENBQUNGLE9BQU9HLFNBQVIsSUFBcUIsQ0FBQ0gsT0FBT0csU0FBUCxDQUFpQkMsYUFBdkMsSUFBd0QsQ0FBQ0osT0FBT0csU0FBUCxDQUFpQkMsYUFBakIsQ0FBK0JDLEdBQTVGLEVBQWlHO0FBQzdGLFVBQU0scUJBQVNDLHlCQUFULEVBQTRCLGVBQTVCLENBQU47QUFDSDs7QUFFRCxNQUFJLENBQUNOLE9BQU9PLFNBQVIsSUFBcUIsQ0FBQ1AsT0FBT08sU0FBUCxDQUFpQkMsTUFBM0MsRUFBbUQ7QUFDL0MsVUFBTSxxQkFBU0Msd0JBQVQsRUFBMkIsUUFBM0IsQ0FBTjtBQUNIOztBQUVELE1BQUksQ0FBQ1QsT0FBT0MsSUFBUCxDQUFZMkQsZUFBWixDQUE0QkMsVUFBakMsRUFBNkM7QUFDekMsVUFBTSxxQkFBU0MsOEJBQVQsQ0FBTjtBQUNIOztBQUVELFFBQU10RCxTQUFTLElBQUlSLE9BQU9DLElBQVAsQ0FBWVUsR0FBWixDQUFnQkMsUUFBcEIsQ0FBNkJaLE9BQU9HLFNBQVAsQ0FBaUJDLGFBQWpCLENBQStCQyxHQUE1RCxFQUFpRUwsT0FBT08sU0FBUCxDQUFpQkMsTUFBbEYsQ0FBZjtBQUNBQSxTQUFPTSxPQUFQLENBQ0tpRCxTQURMLENBQ2VULHFCQURmLEVBRUtVLElBRkwsQ0FFVTtBQUNGUixVQUFNRTtBQURKLEdBRlYsRUFLS08sRUFMTCxDQUtRLE9BTFIsRUFLaUIvQixNQUxqQixFQU1LK0IsRUFOTCxDQU1RLFNBTlIsRUFNbUJDLFdBQVdQLFFBQVFPLFFBQVFDLGVBQWhCLENBTjlCO0FBT0gsQ0ExQm9GLENBQTlFO0FBNEJQOzs7Ozs7Ozs7OztBQU9PLE1BQU1DLG1CQUFtQixDQUFDQyxnQkFBZ0IsTUFBTSxDQUFFLENBQXpCLEVBQTJCQyxnQkFBZ0IsTUFBTSxDQUFFLENBQW5ELEVBQXFEdEUsU0FBUyxFQUE5RCxLQUFxRTtBQUVqRyxNQUFJLENBQUNBLE9BQU9DLElBQVosRUFBa0I7QUFDZCxVQUFNLHFCQUFTQyxxQkFBVCxDQUFOO0FBQ0g7O0FBRUQsTUFBSSxDQUFDRixPQUFPRyxTQUFSLElBQXFCLENBQUNILE9BQU9HLFNBQVAsQ0FBaUJDLGFBQXZDLElBQXdELENBQUNKLE9BQU9HLFNBQVAsQ0FBaUJDLGFBQWpCLENBQStCQyxHQUE1RixFQUFpRztBQUM3RixVQUFNLHFCQUFTQyx5QkFBVCxFQUE0QixlQUE1QixDQUFOO0FBQ0g7O0FBRUQsTUFBSSxDQUFDTixPQUFPTyxTQUFSLElBQXFCLENBQUNQLE9BQU9PLFNBQVAsQ0FBaUJDLE1BQTNDLEVBQW1EO0FBQy9DLFVBQU0scUJBQVNDLHdCQUFULEVBQTJCLFFBQTNCLENBQU47QUFDSDs7QUFFRCxRQUFNQyxNQUFNLElBQUlWLE9BQU9DLElBQVAsQ0FBWVUsR0FBWixDQUFnQkMsUUFBcEIsQ0FBNkJaLE9BQU9HLFNBQVAsQ0FBaUJDLGFBQWpCLENBQStCQyxHQUE1RCxFQUFpRUwsT0FBT08sU0FBUCxDQUFpQkMsTUFBbEYsQ0FBWjtBQUNBRSxNQUFJNkQsTUFBSixDQUFXQyxXQUFYLENBQXVCO0FBQ25CQyxlQUFXO0FBRFEsR0FBdkIsRUFHS1IsRUFITCxDQUdRLE1BSFIsRUFHZ0IsTUFBTVMsR0FBTixJQUFhO0FBRXJCLFFBQUk7QUFFQSxZQUFNQyxTQUFTLE1BQU01QyxZQUFZMkMsSUFBSTNCLElBQUosQ0FBUzRCLE1BQXJCLEVBQTZCM0UsTUFBN0IsQ0FBckI7QUFDQXFFLG9CQUFjO0FBQ1ZuRCxpQkFBU3dELElBQUkzQixJQUFKLENBQVM0QixNQURSO0FBRVZBLGNBRlU7QUFHVkMsZ0JBQVEsU0FIRTtBQUlWQyxlQUFPO0FBSkcsT0FBZDtBQU1ILEtBVEQsQ0FTRSxPQUFNN0MsR0FBTixFQUFXO0FBQ1RzQyxvQkFBY3RDLEdBQWQ7QUFDSDtBQUNKLEdBakJMLEVBa0JLaUMsRUFsQkwsQ0FrQlEsT0FsQlIsRUFrQmlCSyxhQWxCakI7QUFtQkgsQ0FsQ00iLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEtlcm5lbHMgcmVsYXRlZCBtZXRob2RzXG4gKiBUaGlzIGZpbGUgaXQgaXMgYSBwYXJ0IG9mIHRoZSBQYW5kb3JhIFB5cnJoYSBKYXZhc2NyaXB0IGxpYnJhcnlcbiAqIFxuICogQGZpbGUga2VybmVscy5qc1xuICogQGF1dGhvciBLb3N0aWFudHluIFNteXJub3YgPGtvc3R5c2hAZ21haWwuY29tPlxuICogQGRhdGUgMjAxOFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHBqc0Vycm9yLCB7XG4gICAgQ09OVFJBQ1RfUkVRVUlSRUQsXG4gICAgQUREUkVTU19SRVFVSVJFRCxcbiAgICBXRUIzX1JFUVVJUkVELFxuICAgIFdFQjNfTUVUQU1BU0tfUkVRVUlSRURcbn0gZnJvbSAnLi9oZWxwZXJzL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyB3ZWIzSGVscGVycyBmcm9tICcuL2hlbHBlcnMvd2ViMyc7XG5cbi8qKlxuICogR2V0IEtlcm5lbCBhZGRyZXNzIGJ5IGtlcm5lbCBpZFxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIG9iamVjdCByZXByZXNlbnRzIHRoZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hBZGRyZXNzQnlJZCA9IGFzeW5jIChpZCwgY29uZmlnKSA9PiB7XG5cbiAgICBpZiAoIWNvbmZpZy53ZWIzKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKFdFQjNfUkVRVUlSRUQpO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLmNvbnRyYWN0cyB8fCAhY29uZmlnLmNvbnRyYWN0cy5QYW5kb3JhTWFya2V0IHx8ICFjb25maWcuY29udHJhY3RzLlBhbmRvcmFNYXJrZXQuYWJpKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKENPTlRSQUNUX1JFUVVJUkVELCAnUGFuZG9yYU1hcmtldCcpO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLmFkZHJlc3NlcyB8fCAhY29uZmlnLmFkZHJlc3Nlcy5tYXJrZXQpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoQUREUkVTU19SRVFVSVJFRCwgJ01hcmtldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hciA9IG5ldyBjb25maWcud2ViMy5ldGguQ29udHJhY3QoY29uZmlnLmNvbnRyYWN0cy5QYW5kb3JhTWFya2V0LmFiaSwgY29uZmlnLmFkZHJlc3Nlcy5tYXJrZXQpO1xuICAgIGNvbnN0IGtlcm5lbENvbnRyYWN0ID0gYXdhaXQgbWFyLm1ldGhvZHNcbiAgICAgICAgLmtlcm5lbHMoaWQpXG4gICAgICAgIC5jYWxsKCk7XG4gICAgcmV0dXJuIGtlcm5lbENvbnRyYWN0O1xufTtcblxuLyoqXG4gKiBHZXQgSVBGUyBhZGRyZXNzIGZyb20gS2VybmVsIGNvbnRyYWN0IGJ5IHRoZSBrZXJuZWwgYWRkcmVzc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2Ugb2JqZWN0IHJlcHJlc2VudHMgdGhlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaElwZnNBZGRyZXNzID0gYXN5bmMgKGFkZHJlc3MgPSAnJywgY29uZmlnID0ge30pID0+IHtcblxuICAgIGlmICghY29uZmlnLndlYjMpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoV0VCM19SRVFVSVJFRCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25maWcuY29udHJhY3RzIHx8ICFjb25maWcuY29udHJhY3RzLktlcm5lbCB8fCAhY29uZmlnLmNvbnRyYWN0cy5LZXJuZWwuYWJpKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKENPTlRSQUNUX1JFUVVJUkVELCAnS2VybmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VyID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLktlcm5lbC5hYmksIGFkZHJlc3MpO1xuICAgIGNvbnN0IGlwZnNBZGRyZXNzID0gYXdhaXQga2VyLm1ldGhvZHNcbiAgICAgICAgLmlwZnNBZGRyZXNzKClcbiAgICAgICAgLmNhbGwoKTtcbiAgICByZXR1cm4gU3RyaW5nKGlwZnNBZGRyZXNzKTtcbn07XG5cbi8qKlxuICogR2V0IGRhdGEgZGltIGZyb20gS2VybmVsIGNvbnRyYWN0IGJ5IHRoZSBrZXJuZWwgYWRkcmVzc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2Ugb2JqZWN0IHJlcHJlc2VudHMgdGhlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaERhdGFEaW0gPSBhc3luYyAoYWRkcmVzcyA9ICcnLCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgaWYgKCFjb25maWcud2ViMykge1xuICAgICAgICB0aHJvdyBwanNFcnJvcihXRUIzX1JFUVVJUkVEKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5jb250cmFjdHMgfHwgIWNvbmZpZy5jb250cmFjdHMuS2VybmVsIHx8ICFjb25maWcuY29udHJhY3RzLktlcm5lbC5hYmkpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoQ09OVFJBQ1RfUkVRVUlSRUQsICdLZXJuZWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXIgPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuS2VybmVsLmFiaSwgYWRkcmVzcyk7XG4gICAgY29uc3QgZGF0YURpbSA9IGF3YWl0IGtlci5tZXRob2RzXG4gICAgICAgIC5kYXRhRGltKClcbiAgICAgICAgLmNhbGwoKTtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGRhdGFEaW0sIDEwKTtcbn07XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgcHJpY2UgZnJvbSBLZXJuZWwgY29udHJhY3QgYnkgdGhlIGtlcm5lbCBhZGRyZXNzXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIExpYnJhcnkgY29uZmlnIChwcm92aWRlZCBieSB0aGUgcHJveHkgYnV0IGNhbiBiZSBvdmVycmlkZGVuKVxuICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSBvYmplY3QgcmVwcmVzZW50cyB0aGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoQ3VycmVudFByaWNlID0gYXN5bmMgKGFkZHJlc3MgPSAnJywgY29uZmlnID0ge30pID0+IHtcblxuICAgIGlmICghY29uZmlnLndlYjMpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoV0VCM19SRVFVSVJFRCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25maWcuY29udHJhY3RzIHx8ICFjb25maWcuY29udHJhY3RzLktlcm5lbCB8fCAhY29uZmlnLmNvbnRyYWN0cy5LZXJuZWwuYWJpKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKENPTlRSQUNUX1JFUVVJUkVELCAnS2VybmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VyID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLktlcm5lbC5hYmksIGFkZHJlc3MpO1xuICAgIGNvbnN0IGN1cnJlbnRQcmljZSA9IGF3YWl0IGtlci5tZXRob2RzXG4gICAgICAgIC5jdXJyZW50UHJpY2UoKVxuICAgICAgICAuY2FsbCgpO1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoY3VycmVudFByaWNlLCAxMCk7XG59O1xuXG4vKipcbiAqIEdldCBjb21wbGV4aXR5IGZyb20gS2VybmVsIGNvbnRyYWN0IGJ5IHRoZSBrZXJuZWwgYWRkcmVzc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2Ugb2JqZWN0IHJlcHJlc2VudHMgdGhlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaENvbXBsZXhpdHkgPSBhc3luYyAoYWRkcmVzcyA9ICcnLCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgaWYgKCFjb25maWcud2ViMykge1xuICAgICAgICB0aHJvdyBwanNFcnJvcihXRUIzX1JFUVVJUkVEKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5jb250cmFjdHMgfHwgIWNvbmZpZy5jb250cmFjdHMuS2VybmVsIHx8ICFjb25maWcuY29udHJhY3RzLktlcm5lbC5hYmkpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoQ09OVFJBQ1RfUkVRVUlSRUQsICdLZXJuZWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXIgPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuS2VybmVsLmFiaSwgYWRkcmVzcyk7XG4gICAgY29uc3QgY29tcGxleGl0eSA9IGF3YWl0IGtlci5tZXRob2RzXG4gICAgICAgIC5jb21wbGV4aXR5KClcbiAgICAgICAgLmNhbGwoKTtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGNvbXBsZXhpdHksIDEwKTtcbn07XG5cbi8qKlxuICogR2V0IEtlcm5lbCBieSB0aGUga2VybmVsIGFkZHJlc3NcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBvYmplY3QgcmVwcmVzZW50cyB0aGUge09iamVjdFtdfVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hLZXJuZWwgPSBhc3luYyAoYWRkcmVzcyA9ICcnLCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgdHJ5IHtcblxuICAgICAgICBjb25zdCBpcGZzQWRkcmVzcyA9IGF3YWl0IGZldGNoSXBmc0FkZHJlc3MoYWRkcmVzcywgY29uZmlnKTtcbiAgICAgICAgY29uc3QgZGF0YURpbSA9IGF3YWl0IGZldGNoRGF0YURpbShhZGRyZXNzLCBjb25maWcpO1xuICAgICAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBhd2FpdCBmZXRjaEN1cnJlbnRQcmljZShhZGRyZXNzLCBjb25maWcpO1xuICAgICAgICBjb25zdCBjb21wbGV4aXR5ID0gYXdhaXQgZmV0Y2hDb21wbGV4aXR5KGFkZHJlc3MsIGNvbmZpZyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBpcGZzQWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGFEaW0sXG4gICAgICAgICAgICBjdXJyZW50UHJpY2UsXG4gICAgICAgICAgICBjb21wbGV4aXR5XG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYWxsIGtlcm5lbHNcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIG9iamVjdCByZXByZXNlbnRzIHRoZSB7T2JqZWN0W119XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEFsbCA9IGFzeW5jIChjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgbGV0IGlkID0gMDtcbiAgICBsZXQgcmVjb3JkcyA9IFtdO1xuICAgIGxldCBlcnJvciA9IFtdO1xuXG4gICAgdHJ5IHtcblxuICAgICAgICAvLyBAdG9kbyBBZGQgbWV0aG9kIGdldEtlcm5lbHNDb3VudCB0byB0aGUgUGFuZG9yYU1hcmtldCBjb250cmFjdCBmb3IgYXZvaWQgaXRlcmF0aW5nIHdpdGggXCJ0cnkgY2F0Y2hcIlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBrZXJuZWxBZGRyZXNzID0gYXdhaXQgZmV0Y2hBZGRyZXNzQnlJZChpZCsrLCBjb25maWcpOy8vIGNhbiBiZSAweDBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCtrZXJuZWxBZGRyZXNzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXJuZWxPYmogPSBhd2FpdCBmZXRjaEtlcm5lbChrZXJuZWxBZGRyZXNzLCBjb25maWcpO1xuXG4gICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAuLi5rZXJuZWxPYmpcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXJyb3IucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGtlcm5lbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBlcnJvci5wdXNoKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnIubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZWNvcmRzLFxuICAgICAgICBlcnJvclxuICAgIH07XG59O1xuXG4vKipcbiAqIERlcGxveSBLZXJuZWwgY29udHJhY3QgdG8gdGhlIG5ldHdvcmtcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGtlcm5lbElwZnNIYXNoIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgeyBwdWJsaXNoZXIsIGRpbWVuc2lvbiwgY29tcGxleGl0eSwgcHJpY2UgfSBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBvYmplY3QgcmVzb2x2ZWQgdG8gY29udHJhY3QgYWRkcmVzc1xuICovXG5leHBvcnQgY29uc3QgZGVwbG95ID0gYXN5bmMgKGtlcm5lbElwZnNIYXNoLCB7IHB1Ymxpc2hlciwgZGltZW5zaW9uLCBjb21wbGV4aXR5LCBwcmljZSB9LCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgaWYgKCFjb25maWcud2ViMykge1xuICAgICAgICB0aHJvdyBwanNFcnJvcihXRUIzX1JFUVVJUkVEKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5jb250cmFjdHMgfHwgIWNvbmZpZy5jb250cmFjdHMuS2VybmVsIHx8ICFjb25maWcuY29udHJhY3RzLktlcm5lbC5hYmkpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoQ09OVFJBQ1RfUkVRVUlSRUQsICdLZXJuZWwnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcmdzID0gW2NvbmZpZy53ZWIzLnV0aWxzLnRvSGV4KGtlcm5lbElwZnNIYXNoKSwgZGltZW5zaW9uLCBjb21wbGV4aXR5LCBwcmljZV07XG4gICAgICAgIFxuICAgICAgICAvLyBFc3RpbWF0ZSByZXF1aXJlZCBhbW91bnQgb2YgZ2FzXG4gICAgICAgIGNvbnN0IGdhcyA9IGF3YWl0IHdlYjNIZWxwZXJzLmVzdGltYXRlR2FzKGNvbmZpZy5jb250cmFjdHMuS2VybmVsLmJ5dGVjb2RlLCBhcmdzLCBjb25maWcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgZGVwbG95IGtlcm5lbCBjb250cmFjdFxuICAgICAgICBjb25zdCBrZXJuZWxDb250cmFjdEFkZHJlc3MgPSBhd2FpdCB3ZWIzSGVscGVycy5kZXBsb3lDb250cmFjdChjb25maWcuY29udHJhY3RzLktlcm5lbCwge1xuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIGZyb206IHB1Ymxpc2hlcixcbiAgICAgICAgICAgIGdhczogTnVtYmVyLnBhcnNlSW50KGdhcyAqIDEuNSwgMTApXG4gICAgICAgIH0sIGNvbmZpZyk7XG5cbiAgICAgICAgcmV0dXJuIGtlcm5lbENvbnRyYWN0QWRkcmVzcztcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBrZXJuZWwgdG8gbWFya2V0XG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXJuZWxDb250cmFjdEFkZHJlc3MgXG4gKiBAcGFyYW0ge1N0cmluZ30gcHVibGlzaGVyQWRkcmVzcyBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBvYmplY3QgcmVzb2x2ZWQgdG8ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRUb01hcmtldCA9IChrZXJuZWxDb250cmFjdEFkZHJlc3MsIHB1Ymxpc2hlckFkZHJlc3MsIGNvbmZpZyA9IHt9KSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICBpZiAoIWNvbmZpZy53ZWIzKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKFdFQjNfUkVRVUlSRUQpO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLmNvbnRyYWN0cyB8fCAhY29uZmlnLmNvbnRyYWN0cy5QYW5kb3JhTWFya2V0IHx8ICFjb25maWcuY29udHJhY3RzLlBhbmRvcmFNYXJrZXQuYWJpKSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKENPTlRSQUNUX1JFUVVJUkVELCAnUGFuZG9yYU1hcmtldCcpO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLmFkZHJlc3NlcyB8fCAhY29uZmlnLmFkZHJlc3Nlcy5tYXJrZXQpIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoQUREUkVTU19SRVFVSVJFRCwgJ01hcmtldCcpO1xuICAgIH1cblxuICAgIGlmICghY29uZmlnLndlYjMuY3VycmVudFByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgdGhyb3cgcGpzRXJyb3IoV0VCM19NRVRBTUFTS19SRVFVSVJFRCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFya2V0ID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLlBhbmRvcmFNYXJrZXQuYWJpLCBjb25maWcuYWRkcmVzc2VzLm1hcmtldCk7XG4gICAgbWFya2V0Lm1ldGhvZHNcbiAgICAgICAgLmFkZEtlcm5lbChrZXJuZWxDb250cmFjdEFkZHJlc3MpXG4gICAgICAgIC5zZW5kKHtcbiAgICAgICAgICAgIGZyb206IHB1Ymxpc2hlckFkZHJlc3NcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgLm9uKCdyZWNlaXB0JywgcmVjZWlwdCA9PiByZXNvbHZlKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKSk7XG59KTtcblxuLyoqXG4gKiBIYW5kbGUgZXZlbnQgS2VybmVsQWRkZWRcbiAqIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RvcmVDYWxsYmFjayBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKi9cbmV4cG9ydCBjb25zdCBldmVudEtlcm5lbEFkZGVkID0gKHN0b3JlQ2FsbGJhY2sgPSAoKSA9PiB7fSwgZXJyb3JDYWxsYmFjayA9ICgpID0+IHt9LCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgaWYgKCFjb25maWcud2ViMykge1xuICAgICAgICB0aHJvdyBwanNFcnJvcihXRUIzX1JFUVVJUkVEKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5jb250cmFjdHMgfHwgIWNvbmZpZy5jb250cmFjdHMuUGFuZG9yYU1hcmtldCB8fCAhY29uZmlnLmNvbnRyYWN0cy5QYW5kb3JhTWFya2V0LmFiaSkge1xuICAgICAgICB0aHJvdyBwanNFcnJvcihDT05UUkFDVF9SRVFVSVJFRCwgJ1BhbmRvcmFNYXJrZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5hZGRyZXNzZXMgfHwgIWNvbmZpZy5hZGRyZXNzZXMubWFya2V0KSB7XG4gICAgICAgIHRocm93IHBqc0Vycm9yKEFERFJFU1NfUkVRVUlSRUQsICdNYXJrZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXIgPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuUGFuZG9yYU1hcmtldC5hYmksIGNvbmZpZy5hZGRyZXNzZXMubWFya2V0KTtcbiAgICBtYXIuZXZlbnRzLktlcm5lbEFkZGVkKHtcbiAgICAgICAgZnJvbUJsb2NrOiAwXG4gICAgfSlcbiAgICAgICAgLm9uKCdkYXRhJywgYXN5bmMgcmVzID0+IHtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGtlcm5lbCA9IGF3YWl0IGZldGNoS2VybmVsKHJlcy5hcmdzLmtlcm5lbCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBzdG9yZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVzLmFyZ3Mua2VybmVsLFxuICAgICAgICAgICAgICAgICAgICBrZXJuZWwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2NyZWF0ZWQnLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogJ1BhbmRvcmFNYXJrZXQuS2VybmVsQWRkZWQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGVycm9yQ2FsbGJhY2spO1xufTtcbiJdfQ==