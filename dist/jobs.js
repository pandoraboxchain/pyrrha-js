/**
 * Cognitive Jobs related methods
 * This file it is a part of the Pandora Pyrrha Javascript library
 * 
 * @file jobs.js
 * @author Kostiantyn Smyrnov <kostysh@gmail.com>
 * @date 2018
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventCognitiveJobCreated = exports.fetchAll = exports.create = exports.fetchJobsIds = exports.fetchJobDetails = exports.fetchCompletedJobsCount = exports.fetchActiveJobsCount = exports.fetchJobControllerAddress = void 0;

var expect = _interopRequireWildcard(require("./helpers/expect"));

var _errors = _interopRequireWildcard(require("./helpers/errors"));

var _kernels = require("./kernels");

var _datasets = require("./datasets");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const localCache = new Map();
/**
 * Get job controller address
 * 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise<{String}>} 
 */

const fetchJobControllerAddress = async (config = {}) => {
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'addresses.Pandora': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pandora']
    },
    'contracts.Pandora.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pandora']
    }
  });
  const pan = new config.web3.eth.Contract(config.contracts.Pandora.abi, config.addresses.Pandora);
  const jobController = await pan.methods.jobController().call(); // save for later use

  localCache.set('jobController', jobController);
  return jobController;
};
/**
 * Get active jobs count 
 * 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise<{Number}>} 
 */


exports.fetchJobControllerAddress = fetchJobControllerAddress;

const fetchActiveJobsCount = async (config = {}) => {
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.CognitiveJobController.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['CognitiveJobController']
    }
  });
  let jobController = localCache.get('jobController');

  if (!jobController) {
    jobController = await fetchJobControllerAddress(config);
  }

  const jctrl = new config.web3.eth.Contract(config.contracts.CognitiveJobController.abi, jobController);
  const count = await jctrl.methods.activeJobsCount().call();
  return Number.parseInt(count, 10);
};
/**
 * Get completed jobs count 
 * 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise<{Number}>} 
 */


exports.fetchActiveJobsCount = fetchActiveJobsCount;

const fetchCompletedJobsCount = async (config = {}) => {
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.CognitiveJobController.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['CognitiveJobController']
    }
  });
  let jobController = localCache.get('jobController');

  if (!jobController) {
    jobController = await fetchJobControllerAddress(config);
  }

  const jctrl = new config.web3.eth.Contract(config.contracts.CognitiveJobController.abi, jobController);
  const count = await jctrl.methods.completedJobsCount().call();
  return Number.parseInt(count, 10);
};
/**
 * Get job details 
 * 
 * @param {String} address Job address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise<{Number}>} 
 */


exports.fetchCompletedJobsCount = fetchCompletedJobsCount;

const fetchJobDetails = async (address, config = {}) => {
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.CognitiveJobController.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['CognitiveJobController']
    }
  });
  let jobController = localCache.get('jobController');

  if (!jobController) {
    jobController = await fetchJobControllerAddress(config);
  }

  const jctrl = new config.web3.eth.Contract(config.contracts.CognitiveJobController.abi, jobController);
  const {
    kernel,
    dataset,
    complexity,
    description,
    activeWorkers,
    progress,
    state
  } = await jctrl.methods.getCognitiveJobDetails(address).call();
  const ipfsResults = await Promise.all(activeWorkers.map((_, index) => jctrl.methods.getCognitiveJobResults(address, index).call()));
  const utf8description = description ? config.web3.utils.hexToUtf8(description) : '';
  return {
    address,
    kernel,
    dataset,
    activeWorkers,
    ipfsResults: ipfsResults.map(result => result ? config.web3.utils.hexToUtf8(result) : result).filter(res => res),
    complexity: Number(complexity),
    progress: Number(progress),
    state: Number(state),
    description: utf8description.substr(2),
    jobType: utf8description.substr(0, 1)
  };
};
/**
 * Get jobs Id from the "source"
 * 
 * @param {String} from source activeJobs or completedJobs
 * @param {Number} count
 * @param {Object} options
 * @returns {Promise<[{String}]>} 
 */


exports.fetchJobDetails = fetchJobDetails;

const fetchJobsIds = async (source, count = 0, config = {}) => {
  expect.all({
    source
  }, {
    'source': {
      type: 'enum',
      values: ['activeJobs', 'completedJobs']
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.CognitiveJobController.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['CognitiveJobController']
    }
  });
  let jobController = localCache.get('jobController');

  if (!jobController) {
    jobController = await fetchJobControllerAddress(config);
  } // numbers sequence from 0 to count


  const counts = [...Array(count).keys()];
  const jctrl = new config.web3.eth.Contract(config.contracts.CognitiveJobController.abi, jobController);
  const addresses = await Promise.all(counts.map(index => jctrl.methods.getJobId(index, source === 'activeJobs').call()));
  return addresses;
};
/**
 * Create cognitive job contract
 * 
 * @param {Object} options
 * @param {String} from Publisher address
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} Promise object resolved to add status (boolean)
 */


exports.fetchJobsIds = fetchJobsIds;

const create = ({
  kernel,
  dataset,
  complexity,
  jobType,
  description,
  deposit
}, from, config = {}) => new Promise((resolve, reject) => {
  expect.all({
    kernel,
    dataset,
    complexity,
    jobType,
    description,
    deposit,
    from
  }, {
    'kernel': {
      type: 'address'
    },
    'dataset': {
      type: 'address'
    },
    'complexity': {
      type: 'number'
    },
    'jobType': {
      type: 'string'
    },
    'description': {
      type: 'string'
    },
    'deposit': {
      type: 'number'
    },
    'from': {
      type: 'address'
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.Pandora.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pandora']
    },
    'addresses.Pandora': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pandora']
    }
  });
  const pan = new config.web3.eth.Contract(config.contracts.Pandora.abi, config.addresses.Pandora);
  pan.methods.createCognitiveJob(kernel, dataset, complexity, config.web3.utils.utf8ToHex(`${jobType};${description}`)).send({
    value: config.web3.utils.toWei(String(deposit)),
    from,
    gas: 6700000 // because this workflow is too greedy

  }).on('error', reject).on('receipt', receipt => {
    try {
      if (Number(receipt.status) === 0) {
        return reject((0, _errors.default)(_errors.TRANSACTION_UNSUCCESSFUL));
      }

      if (receipt.events.CognitiveJobQueued) {
        return resolve(receipt.events.CognitiveJobQueued.returnValues.jobId);
      }

      resolve(receipt.events.CognitiveJobCreated.returnValues.jobId);
    } catch (err) {
      reject(err);
    }
  });
});
/**
 * Get all jobs
 * 
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Promise} A Promise object represents the {Object[]} 
 */


exports.create = create;

const fetchAll = async (config = {}) => {
  let records = [];
  let error = [];

  try {
    const [activeCount, completedCount] = await Promise.all([fetchActiveJobsCount(config), fetchCompletedJobsCount(config)]);
    const [activeJobsIds, completedJobsIds] = await Promise.all([fetchJobsIds('activeJobs', activeCount, config), fetchJobsIds('completedJobs', completedCount, config)]);
    const allJobsIds = [...activeJobsIds, ...completedJobsIds];
    records = await Promise.all(allJobsIds.map(jobId => fetchJobDetails(jobId, config)));
  } catch (err) {
    error.push({
      error: err.message
    });
  }

  return {
    records,
    error
  };
};
/**
 * Handle event CognitiveJobCreated
 * 
 * @param {Object} options Event handler options
 * @param {Object} config Library config (provided by the proxy but can be overridden)
 * @returns {Object} Object with chained callbacks #data and #error
 */


exports.fetchAll = fetchAll;

const eventCognitiveJobCreated = (options = {}, config = {}) => {
  expect.all({
    options
  }, {
    'options': {
      type: 'object'
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.Pandora.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pandora']
    },
    'addresses.Pandora': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pandora']
    }
  });
  const callbacks = {
    onData: () => {},
    onError: () => {}
  };
  const chain = {
    data: (cb = () => {}) => {
      callbacks.onData = cb;
      return chain;
    },
    error: (cb = () => {}) => {
      callbacks.onError = cb;
      return chain;
    }
  };
  const pan = new config.web3.eth.Contract(config.contracts.Pandora.abi, config.addresses.Pandora);
  chain.event = pan.events.CognitiveJobCreated(options).on('data', async res => {
    try {
      const jobDetails = await fetchJobDetails(res.returnValues.jobId, config);
      callbacks.onData({
        records: [jobDetails]
      });
    } catch (err) {
      callbacks.onError(err);
    }
  }).on('error', callbacks.onError);
  return chain;
};

exports.eventCognitiveJobCreated = eventCognitiveJobCreated;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9qb2JzLmpzIl0sIm5hbWVzIjpbImxvY2FsQ2FjaGUiLCJNYXAiLCJmZXRjaEpvYkNvbnRyb2xsZXJBZGRyZXNzIiwiY29uZmlnIiwiZXhwZWN0IiwiYWxsIiwidHlwZSIsImNvZGUiLCJXRUIzX1JFUVVJUkVEIiwiQUREUkVTU19SRVFVSVJFRCIsImFyZ3MiLCJDT05UUkFDVF9SRVFVSVJFRCIsInBhbiIsIndlYjMiLCJldGgiLCJDb250cmFjdCIsImNvbnRyYWN0cyIsIlBhbmRvcmEiLCJhYmkiLCJhZGRyZXNzZXMiLCJqb2JDb250cm9sbGVyIiwibWV0aG9kcyIsImNhbGwiLCJzZXQiLCJmZXRjaEFjdGl2ZUpvYnNDb3VudCIsImdldCIsImpjdHJsIiwiQ29nbml0aXZlSm9iQ29udHJvbGxlciIsImNvdW50IiwiYWN0aXZlSm9ic0NvdW50IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJmZXRjaENvbXBsZXRlZEpvYnNDb3VudCIsImNvbXBsZXRlZEpvYnNDb3VudCIsImZldGNoSm9iRGV0YWlscyIsImFkZHJlc3MiLCJrZXJuZWwiLCJkYXRhc2V0IiwiY29tcGxleGl0eSIsImRlc2NyaXB0aW9uIiwiYWN0aXZlV29ya2VycyIsInByb2dyZXNzIiwic3RhdGUiLCJnZXRDb2duaXRpdmVKb2JEZXRhaWxzIiwiaXBmc1Jlc3VsdHMiLCJQcm9taXNlIiwibWFwIiwiXyIsImluZGV4IiwiZ2V0Q29nbml0aXZlSm9iUmVzdWx0cyIsInV0ZjhkZXNjcmlwdGlvbiIsInV0aWxzIiwiaGV4VG9VdGY4IiwicmVzdWx0IiwiZmlsdGVyIiwicmVzIiwic3Vic3RyIiwiam9iVHlwZSIsImZldGNoSm9ic0lkcyIsInNvdXJjZSIsInZhbHVlcyIsImNvdW50cyIsIkFycmF5Iiwia2V5cyIsImdldEpvYklkIiwiY3JlYXRlIiwiZGVwb3NpdCIsImZyb20iLCJyZXNvbHZlIiwicmVqZWN0IiwiY3JlYXRlQ29nbml0aXZlSm9iIiwidXRmOFRvSGV4Iiwic2VuZCIsInZhbHVlIiwidG9XZWkiLCJTdHJpbmciLCJnYXMiLCJvbiIsInJlY2VpcHQiLCJzdGF0dXMiLCJUUkFOU0FDVElPTl9VTlNVQ0NFU1NGVUwiLCJldmVudHMiLCJDb2duaXRpdmVKb2JRdWV1ZWQiLCJyZXR1cm5WYWx1ZXMiLCJqb2JJZCIsIkNvZ25pdGl2ZUpvYkNyZWF0ZWQiLCJlcnIiLCJmZXRjaEFsbCIsInJlY29yZHMiLCJlcnJvciIsImFjdGl2ZUNvdW50IiwiY29tcGxldGVkQ291bnQiLCJhY3RpdmVKb2JzSWRzIiwiY29tcGxldGVkSm9ic0lkcyIsImFsbEpvYnNJZHMiLCJwdXNoIiwibWVzc2FnZSIsImV2ZW50Q29nbml0aXZlSm9iQ3JlYXRlZCIsIm9wdGlvbnMiLCJjYWxsYmFja3MiLCJvbkRhdGEiLCJvbkVycm9yIiwiY2hhaW4iLCJkYXRhIiwiY2IiLCJldmVudCIsImpvYkRldGFpbHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQVNBOzs7Ozs7O0FBRUE7O0FBQ0E7O0FBUUE7O0FBSUE7Ozs7QUFJQSxNQUFNQSxhQUFhLElBQUlDLEdBQUosRUFBbkI7QUFFQTs7Ozs7OztBQU1PLE1BQU1DLDRCQUE0QixPQUFPQyxTQUFTLEVBQWhCLEtBQXVCO0FBRTVEQyxTQUFPQyxHQUFQLENBQVdGLE1BQVgsRUFBbUI7QUFDZixZQUFRO0FBQ0pHLFlBQU0sUUFERjtBQUVKQyxZQUFNQztBQUZGLEtBRE87QUFLZix5QkFBcUI7QUFDakJGLFlBQU0sU0FEVztBQUVqQkMsWUFBTUUsd0JBRlc7QUFHakJDLFlBQU0sQ0FBQyxTQUFEO0FBSFcsS0FMTjtBQVVmLDZCQUF5QjtBQUNyQkosWUFBTSxRQURlO0FBRXJCQyxZQUFNSSx5QkFGZTtBQUdyQkQsWUFBTSxDQUFDLFNBQUQ7QUFIZTtBQVZWLEdBQW5CO0FBaUJBLFFBQU1FLE1BQU0sSUFBSVQsT0FBT1UsSUFBUCxDQUFZQyxHQUFaLENBQWdCQyxRQUFwQixDQUE2QlosT0FBT2EsU0FBUCxDQUFpQkMsT0FBakIsQ0FBeUJDLEdBQXRELEVBQTJEZixP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T0FiTSxFQWFHc0IsVUFBVUUsT0FiYixDQUFkO0FBZUEsU0FBT0MsS0FBUDtBQUNILENBMURNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb2duaXRpdmUgSm9icyByZWxhdGVkIG1ldGhvZHNcbiAqIFRoaXMgZmlsZSBpdCBpcyBhIHBhcnQgb2YgdGhlIFBhbmRvcmEgUHlycmhhIEphdmFzY3JpcHQgbGlicmFyeVxuICogXG4gKiBAZmlsZSBqb2JzLmpzXG4gKiBAYXV0aG9yIEtvc3RpYW50eW4gU215cm5vdiA8a29zdHlzaEBnbWFpbC5jb20+XG4gKiBAZGF0ZSAyMDE4XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyBleHBlY3QgZnJvbSAnLi9oZWxwZXJzL2V4cGVjdCc7XG5pbXBvcnQgcGpzRXJyb3IsIHtcbiAgICBDT05UUkFDVF9SRVFVSVJFRCxcbiAgICBBRERSRVNTX1JFUVVJUkVELFxuICAgIFdFQjNfUkVRVUlSRUQsXG4gICAgVFJBTlNBQ1RJT05fVU5TVUNDRVNTRlVMLFxuICAgIEZBSUxVUkVfRVZFTlRcbn0gZnJvbSAnLi9oZWxwZXJzL2Vycm9ycyc7XG5cbmltcG9ydCB7XG4gICAgZmV0Y2hJcGZzQWRkcmVzcyBhcyBmZXRjaElwZnNBZGRyZXNzQnlLZXJuZWxBZGRyZXNzXG59IGZyb20gJy4va2VybmVscyc7XG5cbmltcG9ydCB7XG4gICAgZmV0Y2hEYXRhc2V0IGFzIGZldGNoRGF0YXNldEJ5RGF0YXNldEFkZHJlc3Ncbn0gZnJvbSAnLi9kYXRhc2V0cyc7XG5cbmNvbnN0IGxvY2FsQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogR2V0IGpvYiBjb250cm9sbGVyIGFkZHJlc3NcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtTdHJpbmd9Pn0gXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEpvYkNvbnRyb2xsZXJBZGRyZXNzID0gYXN5bmMgKGNvbmZpZyA9IHt9KSA9PiB7XG5cbiAgICBleHBlY3QuYWxsKGNvbmZpZywge1xuICAgICAgICAnd2ViMyc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogV0VCM19SRVFVSVJFRFxuICAgICAgICB9LFxuICAgICAgICAnYWRkcmVzc2VzLlBhbmRvcmEnOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydQYW5kb3JhJ11cbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbnRyYWN0cy5QYW5kb3JhLmFiaSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogQ09OVFJBQ1RfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ1BhbmRvcmEnXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBwYW4gPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuUGFuZG9yYS5hYmksIGNvbmZpZy5hZGRyZXNzZXMuUGFuZG9yYSk7XG4gICAgY29uc3Qgam9iQ29udHJvbGxlciA9IGF3YWl0IHBhbi5tZXRob2RzXG4gICAgICAgIC5qb2JDb250cm9sbGVyKClcbiAgICAgICAgLmNhbGwoKTtcblxuICAgIC8vIHNhdmUgZm9yIGxhdGVyIHVzZVxuICAgIGxvY2FsQ2FjaGUuc2V0KCdqb2JDb250cm9sbGVyJywgam9iQ29udHJvbGxlcik7XG4gICAgICAgIFxuICAgIHJldHVybiBqb2JDb250cm9sbGVyO1xufTtcblxuLyoqXG4gKiBHZXQgYWN0aXZlIGpvYnMgY291bnQgXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7TnVtYmVyfT59IFxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hBY3RpdmVKb2JzQ291bnQgPSBhc3luYyAoY29uZmlnID0ge30pID0+IHtcblxuICAgIGV4cGVjdC5hbGwoY29uZmlnLCB7XG4gICAgICAgICd3ZWIzJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBXRUIzX1JFUVVJUkVEXG4gICAgICAgIH0sXG4gICAgICAgICdjb250cmFjdHMuQ29nbml0aXZlSm9iQ29udHJvbGxlci5hYmknOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IENPTlRSQUNUX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydDb2duaXRpdmVKb2JDb250cm9sbGVyJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGpvYkNvbnRyb2xsZXIgPSBsb2NhbENhY2hlLmdldCgnam9iQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFqb2JDb250cm9sbGVyKSB7XG5cbiAgICAgICAgam9iQ29udHJvbGxlciA9IGF3YWl0IGZldGNoSm9iQ29udHJvbGxlckFkZHJlc3MoY29uZmlnKTtcbiAgICB9XG5cbiAgICBjb25zdCBqY3RybCA9IG5ldyBjb25maWcud2ViMy5ldGguQ29udHJhY3QoY29uZmlnLmNvbnRyYWN0cy5Db2duaXRpdmVKb2JDb250cm9sbGVyLmFiaSwgam9iQ29udHJvbGxlcik7XG4gICAgY29uc3QgY291bnQgPSBhd2FpdCBqY3RybC5tZXRob2RzXG4gICAgICAgIC5hY3RpdmVKb2JzQ291bnQoKVxuICAgICAgICAuY2FsbCgpO1xuICAgICAgICBcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGNvdW50LCAxMCk7XG59O1xuXG4vKipcbiAqIEdldCBjb21wbGV0ZWQgam9icyBjb3VudCBcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtOdW1iZXJ9Pn0gXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaENvbXBsZXRlZEpvYnNDb3VudCA9IGFzeW5jIChjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgZXhwZWN0LmFsbChjb25maWcsIHtcbiAgICAgICAgJ3dlYjMnOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IFdFQjNfUkVRVUlSRURcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbnRyYWN0cy5Db2duaXRpdmVKb2JDb250cm9sbGVyLmFiaSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogQ09OVFJBQ1RfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ0NvZ25pdGl2ZUpvYkNvbnRyb2xsZXInXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgam9iQ29udHJvbGxlciA9IGxvY2FsQ2FjaGUuZ2V0KCdqb2JDb250cm9sbGVyJyk7XG5cbiAgICBpZiAoIWpvYkNvbnRyb2xsZXIpIHtcblxuICAgICAgICBqb2JDb250cm9sbGVyID0gYXdhaXQgZmV0Y2hKb2JDb250cm9sbGVyQWRkcmVzcyhjb25maWcpO1xuICAgIH1cblxuICAgIGNvbnN0IGpjdHJsID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLkNvZ25pdGl2ZUpvYkNvbnRyb2xsZXIuYWJpLCBqb2JDb250cm9sbGVyKTtcbiAgICBjb25zdCBjb3VudCA9IGF3YWl0IGpjdHJsLm1ldGhvZHNcbiAgICAgICAgLmNvbXBsZXRlZEpvYnNDb3VudCgpXG4gICAgICAgIC5jYWxsKCk7XG4gICAgICAgIFxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoY291bnQsIDEwKTtcbn07XG5cbi8qKlxuICogR2V0IGpvYiBkZXRhaWxzIFxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBKb2IgYWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbilcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtOdW1iZXJ9Pn0gXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEpvYkRldGFpbHMgPSBhc3luYyAoYWRkcmVzcywgY29uZmlnID0ge30pID0+IHtcblxuICAgIGV4cGVjdC5hbGwoY29uZmlnLCB7XG4gICAgICAgICd3ZWIzJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBXRUIzX1JFUVVJUkVEXG4gICAgICAgIH0sXG4gICAgICAgICdjb250cmFjdHMuQ29nbml0aXZlSm9iQ29udHJvbGxlci5hYmknOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IENPTlRSQUNUX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydDb2duaXRpdmVKb2JDb250cm9sbGVyJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGpvYkNvbnRyb2xsZXIgPSBsb2NhbENhY2hlLmdldCgnam9iQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFqb2JDb250cm9sbGVyKSB7XG5cbiAgICAgICAgam9iQ29udHJvbGxlciA9IGF3YWl0IGZldGNoSm9iQ29udHJvbGxlckFkZHJlc3MoY29uZmlnKTtcbiAgICB9XG5cbiAgICBjb25zdCBqY3RybCA9IG5ldyBjb25maWcud2ViMy5ldGguQ29udHJhY3QoY29uZmlnLmNvbnRyYWN0cy5Db2duaXRpdmVKb2JDb250cm9sbGVyLmFiaSwgam9iQ29udHJvbGxlcik7XG4gICAgXG4gICAgY29uc3QgeyBrZXJuZWwsIGRhdGFzZXQsIGNvbXBsZXhpdHksIGRlc2NyaXB0aW9uLCBhY3RpdmVXb3JrZXJzLCBwcm9ncmVzcywgc3RhdGUgfSA9IGF3YWl0IGpjdHJsLm1ldGhvZHNcbiAgICAgICAgLmdldENvZ25pdGl2ZUpvYkRldGFpbHMoYWRkcmVzcylcbiAgICAgICAgLmNhbGwoKTtcbiAgICBjb25zdCBpcGZzUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGFjdGl2ZVdvcmtlcnMubWFwKChfLCBpbmRleCkgPT4gamN0cmwubWV0aG9kcy5nZXRDb2duaXRpdmVKb2JSZXN1bHRzKGFkZHJlc3MsIGluZGV4KS5jYWxsKCkpKTtcbiAgICBcbiAgICBjb25zdCB1dGY4ZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiA/IGNvbmZpZy53ZWIzLnV0aWxzLmhleFRvVXRmOChkZXNjcmlwdGlvbikgOiAnJztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsIFxuICAgICAgICBrZXJuZWwsXG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGFjdGl2ZVdvcmtlcnMsXG4gICAgICAgIGlwZnNSZXN1bHRzOiBpcGZzUmVzdWx0cy5tYXAocmVzdWx0ID0+IHJlc3VsdCA/IGNvbmZpZy53ZWIzLnV0aWxzLmhleFRvVXRmOChyZXN1bHQpIDogcmVzdWx0KS5maWx0ZXIocmVzID0+IHJlcyksXG4gICAgICAgIGNvbXBsZXhpdHk6IE51bWJlcihjb21wbGV4aXR5KSxcbiAgICAgICAgcHJvZ3Jlc3M6IE51bWJlcihwcm9ncmVzcyksXG4gICAgICAgIHN0YXRlOiBOdW1iZXIoc3RhdGUpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdXRmOGRlc2NyaXB0aW9uLnN1YnN0cigyKSxcbiAgICAgICAgam9iVHlwZTogdXRmOGRlc2NyaXB0aW9uLnN1YnN0cigwLCAxKVxuICAgIH07XG59O1xuXG4vKipcbiAqIEdldCBqb2JzIElkIGZyb20gdGhlIFwic291cmNlXCJcbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IGZyb20gc291cmNlIGFjdGl2ZUpvYnMgb3IgY29tcGxldGVkSm9ic1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8W3tTdHJpbmd9XT59IFxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hKb2JzSWRzID0gYXN5bmMgKHNvdXJjZSwgY291bnQgPSAwLCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgZXhwZWN0LmFsbCh7IHNvdXJjZSB9LCB7XG4gICAgICAgICdzb3VyY2UnOiB7XG4gICAgICAgICAgICB0eXBlOiAnZW51bScsXG4gICAgICAgICAgICB2YWx1ZXM6IFsnYWN0aXZlSm9icycsICdjb21wbGV0ZWRKb2JzJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhwZWN0LmFsbChjb25maWcsIHtcbiAgICAgICAgJ3dlYjMnOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IFdFQjNfUkVRVUlSRURcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbnRyYWN0cy5Db2duaXRpdmVKb2JDb250cm9sbGVyLmFiaSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogQ09OVFJBQ1RfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ0NvZ25pdGl2ZUpvYkNvbnRyb2xsZXInXVxuICAgICAgICB9XG4gICAgfSk7ICAgIFxuXG4gICAgbGV0IGpvYkNvbnRyb2xsZXIgPSBsb2NhbENhY2hlLmdldCgnam9iQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFqb2JDb250cm9sbGVyKSB7XG5cbiAgICAgICAgam9iQ29udHJvbGxlciA9IGF3YWl0IGZldGNoSm9iQ29udHJvbGxlckFkZHJlc3MoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBudW1iZXJzIHNlcXVlbmNlIGZyb20gMCB0byBjb3VudFxuICAgIGNvbnN0IGNvdW50cyA9IFsuLi5BcnJheShjb3VudCkua2V5cygpXTtcblxuICAgIGNvbnN0IGpjdHJsID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLkNvZ25pdGl2ZUpvYkNvbnRyb2xsZXIuYWJpLCBqb2JDb250cm9sbGVyKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCBQcm9taXNlLmFsbChjb3VudHMubWFwKGluZGV4ID0+IGpjdHJsLm1ldGhvZHMuZ2V0Sm9iSWQoaW5kZXgsIHNvdXJjZSA9PT0gJ2FjdGl2ZUpvYnMnKS5jYWxsKCkpKTtcbiAgICAgICAgXG4gICAgcmV0dXJuIGFkZHJlc3Nlcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGNvZ25pdGl2ZSBqb2IgY29udHJhY3RcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tIFB1Ymxpc2hlciBhZGRyZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIExpYnJhcnkgY29uZmlnIChwcm92aWRlZCBieSB0aGUgcHJveHkgYnV0IGNhbiBiZSBvdmVycmlkZGVuKVxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2Ugb2JqZWN0IHJlc29sdmVkIHRvIGFkZCBzdGF0dXMgKGJvb2xlYW4pXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoe2tlcm5lbCwgZGF0YXNldCwgY29tcGxleGl0eSwgam9iVHlwZSwgZGVzY3JpcHRpb24sIGRlcG9zaXR9LCBmcm9tLCBjb25maWcgPSB7fSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgZXhwZWN0LmFsbCh7IGtlcm5lbCwgZGF0YXNldCwgY29tcGxleGl0eSwgam9iVHlwZSwgZGVzY3JpcHRpb24sIGRlcG9zaXQsIGZyb20gfSwge1xuICAgICAgICAna2VybmVsJzoge1xuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnXG4gICAgICAgIH0sXG4gICAgICAgICdkYXRhc2V0Jzoge1xuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnXG4gICAgICAgIH0sXG4gICAgICAgICdjb21wbGV4aXR5Jzoge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2pvYlR5cGUnOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICAnZGVzY3JpcHRpb24nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgIH0sXG4gICAgICAgICdmcm9tJzoge1xuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4cGVjdC5hbGwoY29uZmlnLCB7XG4gICAgICAgICd3ZWIzJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBXRUIzX1JFUVVJUkVEXG4gICAgICAgIH0sXG4gICAgICAgICdjb250cmFjdHMuUGFuZG9yYS5hYmknOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IENPTlRSQUNUX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydQYW5kb3JhJ11cbiAgICAgICAgfSxcbiAgICAgICAgJ2FkZHJlc3Nlcy5QYW5kb3JhJzoge1xuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgY29kZTogQUREUkVTU19SRVFVSVJFRCxcbiAgICAgICAgICAgIGFyZ3M6IFsnUGFuZG9yYSddXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHBhbiA9IG5ldyBjb25maWcud2ViMy5ldGguQ29udHJhY3QoY29uZmlnLmNvbnRyYWN0cy5QYW5kb3JhLmFiaSwgY29uZmlnLmFkZHJlc3Nlcy5QYW5kb3JhKTtcbiAgICBwYW4ubWV0aG9kc1xuICAgICAgICAuY3JlYXRlQ29nbml0aXZlSm9iKGtlcm5lbCwgZGF0YXNldCwgY29tcGxleGl0eSwgY29uZmlnLndlYjMudXRpbHMudXRmOFRvSGV4KGAke2pvYlR5cGV9OyR7ZGVzY3JpcHRpb259YCkpXG4gICAgICAgIC5zZW5kKHtcbiAgICAgICAgICAgIHZhbHVlOiBjb25maWcud2ViMy51dGlscy50b1dlaShTdHJpbmcoZGVwb3NpdCkpLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGdhczogNjcwMDAwMC8vIGJlY2F1c2UgdGhpcyB3b3JrZmxvdyBpcyB0b28gZ3JlZWR5XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIC5vbigncmVjZWlwdCcsIHJlY2VpcHQgPT4ge1xuXG4gICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihyZWNlaXB0LnN0YXR1cykgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHBqc0Vycm9yKFRSQU5TQUNUSU9OX1VOU1VDQ0VTU0ZVTCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmV2ZW50cy5Db2duaXRpdmVKb2JRdWV1ZWQpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVjZWlwdC5ldmVudHMuQ29nbml0aXZlSm9iUXVldWVkLnJldHVyblZhbHVlcy5qb2JJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdC5ldmVudHMuQ29nbml0aXZlSm9iQ3JlYXRlZC5yZXR1cm5WYWx1ZXMuam9iSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufSk7XG5cbi8qKlxuICogR2V0IGFsbCBqb2JzXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTGlicmFyeSBjb25maWcgKHByb3ZpZGVkIGJ5IHRoZSBwcm94eSBidXQgY2FuIGJlIG92ZXJyaWRkZW4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIG9iamVjdCByZXByZXNlbnRzIHRoZSB7T2JqZWN0W119IFxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hBbGwgPSBhc3luYyAoY29uZmlnID0ge30pID0+IHtcbiAgICBsZXQgcmVjb3JkcyA9IFtdO1xuICAgIGxldCBlcnJvciA9IFtdO1xuXG4gICAgdHJ5IHtcblxuICAgICAgICBjb25zdCBbXG4gICAgICAgICAgICBhY3RpdmVDb3VudCxcbiAgICAgICAgICAgIGNvbXBsZXRlZENvdW50XG4gICAgICAgIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBmZXRjaEFjdGl2ZUpvYnNDb3VudChjb25maWcpLFxuICAgICAgICAgICAgZmV0Y2hDb21wbGV0ZWRKb2JzQ291bnQoY29uZmlnKVxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdCBbXG4gICAgICAgICAgICBhY3RpdmVKb2JzSWRzLFxuICAgICAgICAgICAgY29tcGxldGVkSm9ic0lkc1xuICAgICAgICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZmV0Y2hKb2JzSWRzKCdhY3RpdmVKb2JzJywgYWN0aXZlQ291bnQsIGNvbmZpZyksXG4gICAgICAgICAgICBmZXRjaEpvYnNJZHMoJ2NvbXBsZXRlZEpvYnMnLCBjb21wbGV0ZWRDb3VudCwgY29uZmlnKVxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdCBhbGxKb2JzSWRzID0gW1xuICAgICAgICAgICAgLi4uYWN0aXZlSm9ic0lkcyxcbiAgICAgICAgICAgIC4uLmNvbXBsZXRlZEpvYnNJZHNcbiAgICAgICAgXTtcblxuICAgICAgICByZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxsSm9ic0lkcy5tYXAoam9iSWQgPT4gZmV0Y2hKb2JEZXRhaWxzKGpvYklkLCBjb25maWcpKSk7XG4gICAgICAgIFxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGVycm9yLnB1c2goe1xuICAgICAgICAgICAgZXJyb3I6IGVyci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgIH0gICBcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlY29yZHMsXG4gICAgICAgIGVycm9yXG4gICAgfTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGV2ZW50IENvZ25pdGl2ZUpvYkNyZWF0ZWRcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRXZlbnQgaGFuZGxlciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIExpYnJhcnkgY29uZmlnIChwcm92aWRlZCBieSB0aGUgcHJveHkgYnV0IGNhbiBiZSBvdmVycmlkZGVuKVxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggY2hhaW5lZCBjYWxsYmFja3MgI2RhdGEgYW5kICNlcnJvclxuICovXG5leHBvcnQgY29uc3QgZXZlbnRDb2duaXRpdmVKb2JDcmVhdGVkID0gKG9wdGlvbnMgPSB7fSwgY29uZmlnID0ge30pID0+IHtcblxuICAgIGV4cGVjdC5hbGwoeyBvcHRpb25zIH0sIHtcbiAgICAgICAgJ29wdGlvbnMnOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0J1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleHBlY3QuYWxsKGNvbmZpZywge1xuICAgICAgICAnd2ViMyc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogV0VCM19SRVFVSVJFRFxuICAgICAgICB9LFxuICAgICAgICAnY29udHJhY3RzLlBhbmRvcmEuYWJpJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBDT05UUkFDVF9SRVFVSVJFRCxcbiAgICAgICAgICAgIGFyZ3M6IFsnUGFuZG9yYSddXG4gICAgICAgIH0sXG4gICAgICAgICdhZGRyZXNzZXMuUGFuZG9yYSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIGNvZGU6IEFERFJFU1NfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ1BhbmRvcmEnXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgIG9uRGF0YTogKCkgPT4ge30sXG4gICAgICAgIG9uRXJyb3I6ICgpID0+IHt9XG4gICAgfTtcblxuICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgICBkYXRhOiAoY2IgPSAoKSA9PiB7fSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzLm9uRGF0YSA9IGNiO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGNiID0gKCkgPT4ge30pID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5vbkVycm9yID0gY2I7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcGFuID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLlBhbmRvcmEuYWJpLCBjb25maWcuYWRkcmVzc2VzLlBhbmRvcmEpO1xuICAgIGNoYWluLmV2ZW50ID0gcGFuLmV2ZW50cy5Db2duaXRpdmVKb2JDcmVhdGVkKG9wdGlvbnMpXG4gICAgICAgIC5vbignZGF0YScsIGFzeW5jIHJlcyA9PiB7XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBqb2JEZXRhaWxzID0gYXdhaXQgZmV0Y2hKb2JEZXRhaWxzKHJlcy5yZXR1cm5WYWx1ZXMuam9iSWQsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHM6IFtqb2JEZXRhaWxzXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgY2FsbGJhY2tzLm9uRXJyb3IpO1xuXG4gICAgcmV0dXJuIGNoYWluO1xufTtcbiJdfQ==