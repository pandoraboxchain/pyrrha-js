"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transfer = exports.approve = exports.balanceOf = void 0;

var expect = _interopRequireWildcard(require("./helpers/expect"));

var _errors = _interopRequireWildcard(require("./helpers/errors"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Pan token methods
 * This file it is a part of the Pandora Pyrrha Javascript library
 * 
 * @file pan.js
 * @author Kostiantyn Smyrnov <kostysh@gmail.com>
 * @date 2019
 */

/**
 * Get tokens balance
 * 
 * @param {String} address Tokens owner address
 * @param {Object} config Library config (provided by the proxy but can be overridden) 
 */
const balanceOf = async (address = '', config = {}) => {
  expect.all({
    address
  }, {
    'address': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Tokens owner address']
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.Pan.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pan']
    },
    'addresses.Pan': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pan']
    }
  });
  const eco = new config.web3.eth.Contract(config.contracts.Pan.abi, config.addresses.Pan);
  const balance = await eco.methods.balanceOf(address).call();
  return Number.parseInt(balance, 10);
};
/**
 * Approve specific amount of tokens to be spent
 * 
 * @param {String} ownerAddress 
 * @param {String} spenderAddress 
 * @param {Number} value
 * @param {Object} config Library config (provided by the proxy but can be overridden) 
 */


exports.balanceOf = balanceOf;

const approve = (ownerAddress, spenderAddress, value, config = {}) => new Promise((resolve, reject) => {
  expect.all({
    ownerAddress,
    spenderAddress,
    value
  }, {
    'ownerAddress': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Tokens owner address']
    },
    'spenderAddress': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Tokens spender address']
    },
    'value': {
      type: 'number',
      args: ['Amount of tokens']
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.Pan.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pan']
    },
    'addresses.Pan': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pan']
    }
  });
  const pan = new config.web3.eth.Contract(config.contracts.Pan.abi, config.addresses.Pan);
  pan.methods.approve(spenderAddress, config.web3.utils.toHex(value)).send({
    from: ownerAddress
  }).on('error', reject).on('receipt', receipt => {
    if (Number(receipt.status) === 0) {
      return reject((0, _errors.default)(_errors.TRANSACTION_UNSUCCESSFUL));
    }

    resolve(receipt);
  });
});
/**
 * Transfer tokens to the address
 * 
 * @param {String} ownerAddress 
 * @param {String} destinationAddress 
 * @param {Number} value
 * @param {Object} config Library config (provided by the proxy but can be overridden) 
 */


exports.approve = approve;

const transfer = (ownerAddress, destinationAddress, value, config = {}) => new Promise((resolve, reject) => {
  expect.all({
    ownerAddress,
    destinationAddress,
    value
  }, {
    'ownerAddress': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Tokens owner address']
    },
    'destinationAddress': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Tokens destination address']
    },
    'value': {
      type: 'number',
      args: ['Amount of tokens']
    }
  });
  expect.all(config, {
    'web3': {
      type: 'object',
      code: _errors.WEB3_REQUIRED
    },
    'contracts.Pan.abi': {
      type: 'object',
      code: _errors.CONTRACT_REQUIRED,
      args: ['Pan']
    },
    'addresses.Pan': {
      type: 'address',
      code: _errors.ADDRESS_REQUIRED,
      args: ['Pan']
    }
  });
  const pan = new config.web3.eth.Contract(config.contracts.Pan.abi, config.addresses.Pan);
  pan.methods.transfer(destinationAddress, config.web3.utils.toHex(value)).send({
    from: ownerAddress
  }).on('error', reject).on('receipt', receipt => {
    if (Number(receipt.status) === 0) {
      return reject((0, _errors.default)(_errors.TRANSACTION_UNSUCCESSFUL));
    }

    resolve(receipt);
  });
});

exports.transfer = transfer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYW4uanMiXSwibmFtZXMiOlsiYmFsYW5jZU9mIiwiYWRkcmVzcyIsImNvbmZpZyIsImV4cGVjdCIsImFsbCIsInR5cGUiLCJjb2RlIiwiQUREUkVTU19SRVFVSVJFRCIsImFyZ3MiLCJXRUIzX1JFUVVJUkVEIiwiQ09OVFJBQ1RfUkVRVUlSRUQiLCJlY28iLCJ3ZWIzIiwiZXRoIiwiQ29udHJhY3QiLCJjb250cmFjdHMiLCJQYW4iLCJhYmkiLCJhZGRyZXNzZXMiLCJiYWxhbmNlIiwibWV0aG9kcyIsImNhbGwiLCJOdW1iZXIiLCJwYXJzZUludCIsImFwcHJvdmUiLCJvd25lckFkZHJlc3MiLCJzcGVuZGVyQWRkcmVzcyIsInZhbHVlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwYW4iLCJ1dGlscyIsInRvSGV4Iiwic2VuZCIsImZyb20iLCJvbiIsInJlY2VpcHQiLCJzdGF0dXMiLCJUUkFOU0FDVElPTl9VTlNVQ0NFU1NGVUwiLCJ0cmFuc2ZlciIsImRlc3RpbmF0aW9uQWRkcmVzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNBOztBQUNBOzs7O0FBVkE7Ozs7Ozs7OztBQWlCQTs7Ozs7O0FBTU8sTUFBTUEsU0FBUyxHQUFHLE9BQU9DLE9BQU8sR0FBRyxFQUFqQixFQUFxQkMsTUFBTSxHQUFHLEVBQTlCLEtBQXFDO0FBRTFEQyxFQUFBQSxNQUFNLENBQUNDLEdBQVAsQ0FBVztBQUFFSCxJQUFBQTtBQUFGLEdBQVgsRUFBd0I7QUFDcEIsZUFBVztBQUNQSSxNQUFBQSxJQUFJLEVBQUUsU0FEQztBQUVQQyxNQUFBQSxJQUFJLEVBQUVDLHdCQUZDO0FBR1BDLE1BQUFBLElBQUksRUFBRSxDQUFDLHNCQUFEO0FBSEM7QUFEUyxHQUF4QjtBQVFBTCxFQUFBQSxNQUFNLENBQUNDLEdBQVAsQ0FBV0YsTUFBWCxFQUFtQjtBQUNmLFlBQVE7QUFDSkcsTUFBQUEsSUFBSSxFQUFFLFFBREY7QUFFSkMsTUFBQUEsSUFBSSxFQUFFRztBQUZG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LElBQUksRUFBRUc7QUFGRixLQURPO0FBS2YseUJBQXFCO0FBQ2pCSixNQUFBQSxJQUFJLEVBQUUsUUFEVztBQUVqQkMsTUFBQUEsSUFBSSxFQUFFSSx5QkFGVztBQUdqQkYsTUFBQUEsSUFBSSxFQUFFLENBQUMsS0FBRDtBQUhXLEtBTE47QUFVZixxQkFBaUI7QUFDYkgsTUFBQUEsSUFBSSxFQUFFLFNBRE87QUFFYkMsTUFBQUEsSUFBSSxFQUFFQyx3QkFGTztBQUdiQyxNQUFBQSxJQUFJLEVBQUUsQ0FBQyxLQUFEO0FBSE87QUFWRixHQUFuQjtBQWlCQSxRQUFNdUIsR0FBRyxHQUFHLElBQUk3QixNQUFNLENBQUNVLElBQVAsQ0FBWUMsR0FBWixDQUFnQkMsUUFBcEIsQ0FBNkJaLE1BQU0sQ0FBQ2EsU0FBUCxDQUFpQkMsR0FBakIsQ0FBcUJDLEdBQWxELEVBQXVEZixNQUFNLENBQUNnQixTQUFQLENBQWlCRixHQUF4RSxDQUFaO0FBQ0FlLEVBQUFBLEdBQUcsQ0FBQ1gsT0FBSixDQUNLb0IsUUFETCxDQUNjQyxrQkFEZCxFQUNrQ3ZDLE1BQU0sQ0FBQ1UsSUFBUCxDQUFZb0IsS0FBWixDQUFrQkMsS0FBbEIsQ0FBd0JOLEtBQXhCLENBRGxDLEVBRUtPLElBRkwsQ0FFVTtBQUNGQyxJQUFBQSxJQUFJLEVBQUVWO0FBREosR0FGVixFQUtLVyxFQUxMLENBS1EsT0FMUixFQUtpQk4sTUFMakIsRUFNS00sRUFOTCxDQU1RLFNBTlIsRUFNbUJDLE9BQU8sSUFBSTtBQUV0QixRQUFJZixNQUFNLENBQUNlLE9BQU8sQ0FBQ0MsTUFBVCxDQUFOLEtBQTJCLENBQS9CLEVBQWtDO0FBRTlCLGFBQU9SLE1BQU0sQ0FBQyxxQkFBU1MsZ0NBQVQsQ0FBRCxDQUFiO0FBQ0g7O0FBRURWLElBQUFBLE9BQU8sQ0FBQ1EsT0FBRCxDQUFQO0FBQ0gsR0FkTDtBQWVILENBcERpRixDQUEzRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFuIHRva2VuIG1ldGhvZHNcbiAqIFRoaXMgZmlsZSBpdCBpcyBhIHBhcnQgb2YgdGhlIFBhbmRvcmEgUHlycmhhIEphdmFzY3JpcHQgbGlicmFyeVxuICogXG4gKiBAZmlsZSBwYW4uanNcbiAqIEBhdXRob3IgS29zdGlhbnR5biBTbXlybm92IDxrb3N0eXNoQGdtYWlsLmNvbT5cbiAqIEBkYXRlIDIwMTlcbiAqL1xuXG5pbXBvcnQgKiBhcyBleHBlY3QgZnJvbSAnLi9oZWxwZXJzL2V4cGVjdCc7XG5pbXBvcnQgcGpzRXJyb3IsIHtcbiAgICBXRUIzX1JFUVVJUkVELFxuICAgIENPTlRSQUNUX1JFUVVJUkVELFxuICAgIEFERFJFU1NfUkVRVUlSRUQsXG4gICAgVFJBTlNBQ1RJT05fVU5TVUNDRVNTRlVMXG59IGZyb20gJy4vaGVscGVycy9lcnJvcnMnO1xuXG4vKipcbiAqIEdldCB0b2tlbnMgYmFsYW5jZVxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBUb2tlbnMgb3duZXIgYWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbikgXG4gKi9cbmV4cG9ydCBjb25zdCBiYWxhbmNlT2YgPSBhc3luYyAoYWRkcmVzcyA9ICcnLCBjb25maWcgPSB7fSkgPT4ge1xuXG4gICAgZXhwZWN0LmFsbCh7IGFkZHJlc3MgfSwge1xuICAgICAgICAnYWRkcmVzcyc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIGNvZGU6IEFERFJFU1NfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ1Rva2VucyBvd25lciBhZGRyZXNzJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhwZWN0LmFsbChjb25maWcsIHtcbiAgICAgICAgJ3dlYjMnOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IFdFQjNfUkVRVUlSRURcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbnRyYWN0cy5QYW4uYWJpJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBDT05UUkFDVF9SRVFVSVJFRCxcbiAgICAgICAgICAgIGFyZ3M6IFsnUGFuJ11cbiAgICAgICAgfSxcbiAgICAgICAgJ2FkZHJlc3Nlcy5QYW4nOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydQYW4nXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBlY28gPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuUGFuLmFiaSwgY29uZmlnLmFkZHJlc3Nlcy5QYW4pO1xuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBlY28ubWV0aG9kc1xuICAgICAgICAuYmFsYW5jZU9mKGFkZHJlc3MpXG4gICAgICAgIC5jYWxsKCk7XG4gICAgICAgIFxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoYmFsYW5jZSwgMTApO1xufTtcblxuLyoqXG4gKiBBcHByb3ZlIHNwZWNpZmljIGFtb3VudCBvZiB0b2tlbnMgdG8gYmUgc3BlbnRcbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IG93bmVyQWRkcmVzcyBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcGVuZGVyQWRkcmVzcyBcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbikgXG4gKi9cbmV4cG9ydCBjb25zdCBhcHByb3ZlID0gKG93bmVyQWRkcmVzcywgc3BlbmRlckFkZHJlc3MsIHZhbHVlLCBjb25maWcgPSB7fSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIFxuICAgIGV4cGVjdC5hbGwoeyBvd25lckFkZHJlc3MsIHNwZW5kZXJBZGRyZXNzLCB2YWx1ZSB9LCB7XG4gICAgICAgICdvd25lckFkZHJlc3MnOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydUb2tlbnMgb3duZXIgYWRkcmVzcyddXG4gICAgICAgIH0sXG4gICAgICAgICdzcGVuZGVyQWRkcmVzcyc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIGNvZGU6IEFERFJFU1NfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ1Rva2VucyBzcGVuZGVyIGFkZHJlc3MnXVxuICAgICAgICB9LFxuICAgICAgICAndmFsdWUnOiB7XG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIGFyZ3M6IFsnQW1vdW50IG9mIHRva2VucyddXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4cGVjdC5hbGwoY29uZmlnLCB7XG4gICAgICAgICd3ZWIzJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBXRUIzX1JFUVVJUkVEXG4gICAgICAgIH0sXG4gICAgICAgICdjb250cmFjdHMuUGFuLmFiaSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgY29kZTogQ09OVFJBQ1RfUkVRVUlSRUQsXG4gICAgICAgICAgICBhcmdzOiBbJ1BhbiddXG4gICAgICAgIH0sXG4gICAgICAgICdhZGRyZXNzZXMuUGFuJzoge1xuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgY29kZTogQUREUkVTU19SRVFVSVJFRCxcbiAgICAgICAgICAgIGFyZ3M6IFsnUGFuJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcGFuID0gbmV3IGNvbmZpZy53ZWIzLmV0aC5Db250cmFjdChjb25maWcuY29udHJhY3RzLlBhbi5hYmksIGNvbmZpZy5hZGRyZXNzZXMuUGFuKTtcbiAgICBwYW4ubWV0aG9kc1xuICAgICAgICAuYXBwcm92ZShzcGVuZGVyQWRkcmVzcywgY29uZmlnLndlYjMudXRpbHMudG9IZXgodmFsdWUpKVxuICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgICBmcm9tOiBvd25lckFkZHJlc3NcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgLm9uKCdyZWNlaXB0JywgcmVjZWlwdCA9PiB7XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIocmVjZWlwdC5zdGF0dXMpID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHBqc0Vycm9yKFRSQU5TQUNUSU9OX1VOU1VDQ0VTU0ZVTCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICB9KTtcbn0pO1xuXG4vKipcbiAqIFRyYW5zZmVyIHRva2VucyB0byB0aGUgYWRkcmVzc1xuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gb3duZXJBZGRyZXNzIFxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RpbmF0aW9uQWRkcmVzcyBcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBMaWJyYXJ5IGNvbmZpZyAocHJvdmlkZWQgYnkgdGhlIHByb3h5IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbikgXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlciA9IChvd25lckFkZHJlc3MsIGRlc3RpbmF0aW9uQWRkcmVzcywgdmFsdWUsIGNvbmZpZyA9IHt9KSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgXG4gICAgZXhwZWN0LmFsbCh7IG93bmVyQWRkcmVzcywgZGVzdGluYXRpb25BZGRyZXNzLCB2YWx1ZSB9LCB7XG4gICAgICAgICdvd25lckFkZHJlc3MnOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydUb2tlbnMgb3duZXIgYWRkcmVzcyddXG4gICAgICAgIH0sXG4gICAgICAgICdkZXN0aW5hdGlvbkFkZHJlc3MnOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydUb2tlbnMgZGVzdGluYXRpb24gYWRkcmVzcyddXG4gICAgICAgIH0sXG4gICAgICAgICd2YWx1ZSc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgYXJnczogWydBbW91bnQgb2YgdG9rZW5zJ11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhwZWN0LmFsbChjb25maWcsIHtcbiAgICAgICAgJ3dlYjMnOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGNvZGU6IFdFQjNfUkVRVUlSRURcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbnRyYWN0cy5QYW4uYWJpJzoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBjb2RlOiBDT05UUkFDVF9SRVFVSVJFRCxcbiAgICAgICAgICAgIGFyZ3M6IFsnUGFuJ11cbiAgICAgICAgfSxcbiAgICAgICAgJ2FkZHJlc3Nlcy5QYW4nOiB7XG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICBjb2RlOiBBRERSRVNTX1JFUVVJUkVELFxuICAgICAgICAgICAgYXJnczogWydQYW4nXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBwYW4gPSBuZXcgY29uZmlnLndlYjMuZXRoLkNvbnRyYWN0KGNvbmZpZy5jb250cmFjdHMuUGFuLmFiaSwgY29uZmlnLmFkZHJlc3Nlcy5QYW4pO1xuICAgIHBhbi5tZXRob2RzXG4gICAgICAgIC50cmFuc2ZlcihkZXN0aW5hdGlvbkFkZHJlc3MsIGNvbmZpZy53ZWIzLnV0aWxzLnRvSGV4KHZhbHVlKSlcbiAgICAgICAgLnNlbmQoe1xuICAgICAgICAgICAgZnJvbTogb3duZXJBZGRyZXNzXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIC5vbigncmVjZWlwdCcsIHJlY2VpcHQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHJlY2VpcHQuc3RhdHVzKSA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChwanNFcnJvcihUUkFOU0FDVElPTl9VTlNVQ0NFU1NGVUwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgfSk7XG59KTtcbiJdfQ==